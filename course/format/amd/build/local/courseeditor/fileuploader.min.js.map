{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The course file uploader.\n *\n * This module is used to upload files directly into the course.\n *\n * @module     core_courseformat/local/courseeditor/fileuploader\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * @typedef {Object} Handler\n * @property {String} extension the handled extension or * for any\n * @property {String} message the handler message\n * @property {String} module the module name\n */\n\nimport Config from 'core/config';\nimport ModalFactory from 'core/modal_factory';\nimport ModalEvents from 'core/modal_events';\nimport Templates from 'core/templates';\nimport {getFirst} from 'core/normalise';\nimport {prefetchStrings} from 'core/prefetch';\nimport {get_string as getString, get_strings as getStrings} from 'core/str';\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\nimport {processMonitor} from 'core/process_monitor';\nimport {debounce} from 'core/utils';\n\n// Uploading url.\nconst UPLOADURL = Config.wwwroot + '/course/dndupload.php';\nconst DEBOUNCETIMER = 500;\nconst USERCANIGNOREFILESIZELIMITS = -1;\n\n/** @var {ProcessQueue} uploadQueue the internal uploadQueue instance.  */\nlet uploadQueue = null;\n/** @var {Object} handlerManagers the courseId indexed loaded handler managers. */\nlet handlerManagers = {};\n/** @var {Map} courseUpdates the pending course sections updates. */\nlet courseUpdates = new Map();\n/** @var {Object} errors the error messages. */\nlet errors = null;\n\n// Load global strings.\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\nprefetchStrings('core_error', ['dndmaxbytes', 'dndread', 'dndupload', 'dndunkownfile']);\n\n/**\n * Class to upload a file into the course.\n * @private\n */\nclass FileUploader {\n    /**\n     * Class constructor.\n     *\n     * @param {number} courseId the course id\n     * @param {number} sectionId the section id\n     * @param {number} sectionNum the section number\n     * @param {File} fileInfo the file information object\n     * @param {Handler} handler the file selected file handler\n     */\n    constructor(courseId, sectionId, sectionNum, fileInfo, handler) {\n        this.courseId = courseId;\n        this.sectionId = sectionId;\n        this.sectionNum = sectionNum;\n        this.fileInfo = fileInfo;\n        this.handler = handler;\n    }\n\n    /**\n     * Execute the file upload and update the state in the given process.\n     *\n     * @param {LoadingProcess} process the process to store the upload result\n     */\n    execute(process) {\n        const fileInfo = this.fileInfo;\n        const xhr = this._createXhrRequest(process);\n        const formData = this._createUploadFormData();\n\n        // Try reading the file to check it is not a folder, before sending it to the server.\n        const reader = new FileReader();\n        reader.onload = function() {\n            // File was read OK - send it to the server.\n            xhr.open(\"POST\", UPLOADURL, true);\n            xhr.send(formData);\n        };\n        reader.onerror = function() {\n            // Unable to read the file (it is probably a folder) - display an error message.\n            process.setError(errors.dndread);\n        };\n        if (fileInfo.size > 0) {\n            // If this is a non-empty file, try reading the first few bytes.\n            // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\n            reader.readAsText(fileInfo.slice(0, 5));\n        } else {\n            // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\n            // instead of reader.onerror().\n            // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\n            reader.readAsText(fileInfo);\n        }\n    }\n\n    /**\n     * Returns the bind version of execute function.\n     *\n     * This method is used to queue the process into a ProcessQueue instance.\n     *\n     * @returns {Function} the bind function to execute the process\n     */\n    getExecutionFunction() {\n        return this.execute.bind(this);\n    }\n\n    /**\n     * Generate a upload XHR file request.\n     *\n     * @param {LoadingProcess} process the current process\n     * @return {XMLHttpRequest} the XHR request\n     */\n    _createXhrRequest(process) {\n        const xhr = new XMLHttpRequest();\n        // Update the progress bar as the file is uploaded.\n        xhr.upload.addEventListener(\n            'progress',\n            (event) => {\n                if (event.lengthComputable) {\n                    const percent = Math.round((event.loaded * 100) / event.total);\n                    process.setPercentage(percent);\n                }\n            },\n            false\n        );\n        // Wait for the AJAX call to complete.\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState == 1) {\n                // Add a 1% just to indicate that it is uploading.\n                process.setPercentage(1);\n            }\n            // State 4 is DONE. Otherwise the connection is still ongoing.\n            if (xhr.readyState != 4) {\n                return;\n            }\n            if (xhr.status == 200) {\n                var result = JSON.parse(xhr.responseText);\n                if (result && result.error == 0) {\n                    // All OK.\n                    this._finishProcess(process);\n                } else {\n                    process.setError(result.error);\n                }\n            } else {\n                process.setError(errors.dndupload);\n            }\n        };\n        return xhr;\n    }\n\n    /**\n     * Upload a file into the course.\n     *\n     * @return {FormData|null} the new form data object\n     */\n    _createUploadFormData() {\n        const formData = new FormData();\n        try {\n            formData.append('repo_upload_file', this.fileInfo);\n        } catch (error) {\n            throw Error(error.dndread);\n        }\n        formData.append('sesskey', Config.sesskey);\n        formData.append('course', this.courseId);\n        formData.append('section', this.sectionNum);\n        formData.append('module', this.handler.module);\n        formData.append('type', 'Files');\n        return formData;\n    }\n\n    /**\n     * Finishes the current process.\n     * @param {LoadingProcess} process the process\n     */\n    _finishProcess(process) {\n        addRefreshSection(this.courseId, this.sectionId);\n        process.setPercentage(100);\n        process.finish();\n    }\n}\n\n/**\n * The file handler manager class.\n *\n * @private\n */\nclass HandlerManager {\n\n    /** @var {Object} lastHandlers the last handlers selected per each file extension. */\n    lastHandlers = {};\n\n    /** @var {Handler[]|null} allHandlers all the available handlers. */\n    allHandlers = null;\n\n    /**\n     * Class constructor.\n     *\n     * @param {Number} courseId\n     */\n    constructor(courseId) {\n        this.courseId = courseId;\n        this.lastUploadId = 0;\n        this.courseEditor = getCourseEditor(courseId);\n        if (!this.courseEditor) {\n            throw Error('Unkown course editor');\n        }\n        this.maxbytes = this.courseEditor.get('course')?.maxbytes ?? 0;\n    }\n\n    /**\n     * Load the course file handlers.\n     */\n    async loadHandlers() {\n        this.allHandlers = await this.courseEditor.getFileHandlersPromise();\n    }\n\n    /**\n     * Extract the file extension from a fileInfo.\n     *\n     * @param {File} fileInfo\n     * @returns {String} the file extension or an empty string.\n     */\n    getFileExtension(fileInfo) {\n        let extension = '';\n        const dotpos = fileInfo.name.lastIndexOf('.');\n        if (dotpos != -1) {\n            extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\n        }\n        return extension;\n    }\n\n    /**\n     * Check if the file is valid.\n     *\n     * @param {File} fileInfo the file info\n     */\n    validateFile(fileInfo) {\n        if (this.maxbytes !== USERCANIGNOREFILESIZELIMITS && fileInfo.size > this.maxbytes) {\n            throw Error(errors.dndmaxbytes);\n        }\n    }\n\n    /**\n     * Get the file handlers of an specific file.\n     *\n     * @param {File} fileInfo the file indo\n     * @return {Array} Array of handlers\n     */\n    filterHandlers(fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        return this.allHandlers.filter(handler => handler.extension == '*' || handler.extension == extension);\n    }\n\n    /**\n     * Get the Handler to upload a specific file.\n     *\n     * It will ask the used if more than one handler is available.\n     *\n     * @param {File} fileInfo the file info\n     * @returns {Promise<Handler|null>} the selected handler or null if the user cancel\n     */\n    async getFileHandler(fileInfo) {\n        const fileHandlers = this.filterHandlers(fileInfo);\n        if (fileHandlers.length == 0) {\n            throw Error(errors.dndunkownfile);\n        }\n        let fileHandler = null;\n        if (fileHandlers.length == 1) {\n            fileHandler = fileHandlers[0];\n        } else {\n            fileHandler = await this.askHandlerToUser(fileHandlers, fileInfo);\n        }\n        return fileHandler;\n    }\n\n    /**\n     * Ask the user to select a specific handler.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @return {Promise<Handler>} the selected handler\n     */\n    async askHandlerToUser(fileHandlers, fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        // Build the modal parameters from the event data.\n        const modalParams = {\n            title: getString('addresourceoractivity', 'moodle'),\n            body: Templates.render(\n                'core_courseformat/fileuploader',\n                this.getModalData(\n                    fileHandlers,\n                    fileInfo,\n                    this.lastHandlers[extension] ?? null\n                )\n            ),\n            type: ModalFactory.types.SAVE_CANCEL,\n            saveButtonText: getString('upload', 'moodle'),\n        };\n        // Create the modal.\n        const modal = await this.modalBodyRenderedPromise(modalParams);\n        const selectedHandler = await this.modalUserAnswerPromise(modal, fileHandlers);\n        // Cancel action.\n        if (selectedHandler === null) {\n            return null;\n        }\n        // Save last selected handler.\n        this.lastHandlers[extension] = selectedHandler.module;\n        return selectedHandler;\n    }\n\n    /**\n     * Generated the modal template data.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @param {String|null} defaultModule the default module if any\n     * @return {Object} the modal template data.\n     */\n    getModalData(fileHandlers, fileInfo, defaultModule) {\n        const data = {\n            filename: fileInfo.name,\n            uploadid: ++this.lastUploadId,\n            handlers: [],\n        };\n        let hasDefault = false;\n        fileHandlers.forEach((handler, index) => {\n            const isDefault = (defaultModule == handler.module);\n            data.handlers.push({\n                ...handler,\n                selected: isDefault,\n                labelid: `fileuploader_${data.uploadid}`,\n                value: index,\n            });\n            hasDefault = hasDefault || isDefault;\n        });\n        if (!hasDefault && data.handlers.length > 0) {\n            const lastHandler = data.handlers.pop();\n            lastHandler.selected = true;\n            data.handlers.push(lastHandler);\n        }\n        return data;\n    }\n\n    /**\n     * Get the user handler choice.\n     *\n     * Wait for the user answer in the modal and resolve with the selected index.\n     *\n     * @param {Modal} modal the modal instance\n     * @param {Handler[]} fileHandlers the availabvle file handlers\n     * @return {Promise} with the option selected by the user.\n     */\n    modalUserAnswerPromise(modal, fileHandlers) {\n        const modalBody = getFirst(modal.getBody());\n        return new Promise((resolve, reject) => {\n            modal.getRoot().on(\n                ModalEvents.save,\n                event => {\n                    // Get the selected option.\n                    const index = modalBody.querySelector('input:checked').value;\n                    event.preventDefault();\n                    modal.destroy();\n                    if (!fileHandlers[index]) {\n                        reject('Invalid handler selected');\n                    }\n                    resolve(fileHandlers[index]);\n\n                }\n            );\n            modal.getRoot().on(\n                ModalEvents.cancel,\n                () => {\n                    resolve(null);\n                }\n            );\n        });\n    }\n\n    /**\n     * Create a new modal and return a Promise to the body rendered.\n     *\n     * @param {Object} modalParams the modal params\n     * @returns {Promise} the modal body rendered promise\n     */\n    modalBodyRenderedPromise(modalParams) {\n        return new Promise((resolve, reject) => {\n            ModalFactory.create(modalParams).then((modal) => {\n                modal.setRemoveOnClose(true);\n                // Handle body loading event.\n                modal.getRoot().on(ModalEvents.bodyRendered, () => {\n                    resolve(modal);\n                });\n                // Configure some extra modal params.\n                if (modalParams.saveButtonText !== undefined) {\n                    modal.setSaveButtonText(modalParams.saveButtonText);\n                }\n                modal.show();\n                return;\n            }).catch(() => {\n                reject(`Cannot load modal content`);\n            });\n        });\n    }\n}\n\n/**\n * Add a section to refresh.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the seciton id\n */\nfunction addRefreshSection(courseId, sectionId) {\n    let refresh = courseUpdates.get(courseId);\n    if (!refresh) {\n        refresh = new Set();\n    }\n    refresh.add(sectionId);\n    courseUpdates.set(courseId, refresh);\n    refreshCourseEditors();\n}\n\n/**\n * Debounced processing all pending course refreshes.\n * @private\n */\nconst refreshCourseEditors = debounce(\n    () => {\n        const refreshes = courseUpdates;\n        courseUpdates = new Map();\n        refreshes.forEach((sectionIds, courseId) => {\n            const courseEditor = getCourseEditor(courseId);\n            if (!courseEditor) {\n                return;\n            }\n            courseEditor.dispatch('sectionState', [...sectionIds]);\n        });\n    },\n    DEBOUNCETIMER\n);\n\n/**\n * Load and return the course handler manager instance.\n *\n * @param {Number} courseId the course Id to load\n * @returns {Promise<HandlerManager>} promise of the the loaded handleManager\n */\nasync function loadCourseHandlerManager(courseId) {\n    if (handlerManagers[courseId] !== undefined) {\n        return handlerManagers[courseId];\n    }\n    try {\n        const handlerManager = new HandlerManager(courseId);\n        await handlerManager.loadHandlers();\n        handlerManagers[courseId] = handlerManager;\n    } catch (error) {\n        throw error;\n    }\n    return handlerManagers[courseId];\n}\n\n/**\n * Load all the erros messages at once in the module \"errors\" variable.\n * @param {Number} courseId the course id\n */\nasync function loadErrorStrings(courseId) {\n    if (errors !== null) {\n        return;\n    }\n    const courseEditor = getCourseEditor(courseId);\n    const maxbytestext = courseEditor.get('course')?.maxbytestext ?? '0';\n\n    errors = {};\n    const allStrings = [\n        {key: 'dndmaxbytes', component: 'core_error', param: {size: maxbytestext}},\n        {key: 'dndread', component: 'core_error'},\n        {key: 'dndupload', component: 'core_error'},\n        {key: 'dndunkownfile', component: 'core_error'},\n    ];\n    window.console.log(allStrings);\n    const loadedStrings = await getStrings(allStrings);\n    allStrings.forEach(({key}, index) => {\n        errors[key] = loadedStrings[index];\n    });\n}\n\n/**\n * Start a batch file uploading into the course.\n *\n * @private\n * @param {number} courseId the course id.\n * @param {number} sectionId the section id.\n * @param {number} sectionNum the section number.\n * @param {File} fileInfo the file information object\n * @param {HandlerManager} handlerManager the course handler manager\n */\nconst queueFileUpload = async function(courseId, sectionId, sectionNum, fileInfo, handlerManager) {\n    let handler;\n    uploadQueue = await processMonitor.createProcessQueue();\n    try {\n        handlerManager.validateFile(fileInfo);\n        handler = await handlerManager.getFileHandler(fileInfo);\n    } catch (error) {\n        uploadQueue.addError(fileInfo.name, error.message);\n        return;\n    }\n    // If we don't have a handler means the user cancel the upload.\n    if (!handler) {\n        return;\n    }\n    const fileProcessor = new FileUploader(courseId, sectionId, sectionNum, fileInfo, handler);\n    uploadQueue.addPending(fileInfo.name, fileProcessor.getExecutionFunction());\n};\n\n/**\n * Upload a file to the course.\n *\n * This method will show any necesary modal to handle the request.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the section id\n * @param {number} sectionNum the section number\n * @param {Array} files and array of files\n */\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\n    // Get the course handlers.\n    let handlerManager;\n    try {\n        handlerManager = await loadCourseHandlerManager(courseId);\n        await loadErrorStrings(courseId);\n    } catch (error) {\n        throw error;\n    }\n    for (let index = 0; index < files.length; index++) {\n        const fileInfo = files[index];\n        await queueFileUpload(courseId, sectionId, sectionNum, fileInfo, handlerManager);\n    }\n};\n"],"names":["_interopRequireDefault","obj","__esModule","default","_defineProperty","key","value","arg","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","String","Number","_toPrimitive","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","_config","_modal_factory","_modal_events","_templates","UPLOADURL","Config","wwwroot","uploadQueue","handlerManagers","courseUpdates","Map","errors","prefetchStrings","FileUploader","constructor","courseId","sectionId","sectionNum","fileInfo","handler","this","execute","process","xhr","_createXhrRequest","formData","_createUploadFormData","reader","FileReader","onload","open","send","onerror","setError","dndread","size","readAsText","slice","getExecutionFunction","bind","XMLHttpRequest","upload","addEventListener","event","lengthComputable","percent","Math","round","loaded","total","setPercentage","onreadystatechange","readyState","status","result","JSON","parse","responseText","error","_finishProcess","dndupload","FormData","append","Error","sesskey","module","refresh","get","Set","add","set","refreshCourseEditors","addRefreshSection","finish","HandlerManager","_this$courseEditor$ge","_this$courseEditor$ge2","lastUploadId","courseEditor","getCourseEditor","maxbytes","async","allHandlers","getFileHandlersPromise","getFileExtension","extension","dotpos","name","lastIndexOf","substring","length","toLowerCase","validateFile","dndmaxbytes","filterHandlers","filter","fileHandlers","dndunkownfile","fileHandler","askHandlerToUser","_this$lastHandlers$ex","modalParams","title","getString","body","Templates","render","getModalData","lastHandlers","type","ModalFactory","types","SAVE_CANCEL","saveButtonText","modal","modalBodyRenderedPromise","selectedHandler","modalUserAnswerPromise","defaultModule","data","filename","uploadid","handlers","hasDefault","forEach","index","isDefault","push","selected","labelid","concat","lastHandler","pop","modalBody","getFirst","getBody","Promise","resolve","reject","getRoot","on","ModalEvents","save","querySelector","preventDefault","destroy","cancel","create","then","setRemoveOnClose","bodyRendered","setSaveButtonText","show","catch","debounce","refreshes","sectionIds","dispatch","queueFileUpload","handlerManager","processMonitor","createProcessQueue","getFileHandler","addError","message","fileProcessor","addPending","_exports","uploadFilesToCourse","files","loadHandlers","loadCourseHandlerManager","_courseEditor$get$max","_courseEditor$get","maxbytestext","allStrings","component","param","window","console","log","loadedStrings","getStrings","get_strings","_ref","loadErrorStrings"],"mappings":"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"}