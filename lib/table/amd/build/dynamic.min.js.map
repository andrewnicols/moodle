{"version":3,"file":"dynamic.min.js","sources":["../src/dynamic.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module to handle dynamic table features.\n *\n * @module     core_table/dynamic\n * @copyright  2020 Simey Lameze <simey@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport * as Selectors from 'core_table/local/dynamic/selectors';\nimport Events from './local/dynamic/events';\nimport Pending from 'core/pending';\nimport {addIconToContainer} from 'core/loadingicon';\nimport {fetch as fetchTableData} from 'core_table/local/dynamic/repository';\nimport Notification from 'core/notification';\n\nlet watching = false;\n\n/**\n * Ensure that a table is a dynamic table.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Bool}\n */\nconst checkTableIsDynamic = tableRoot => {\n    if (!tableRoot) {\n        // The table is not a dynamic table.\n        throw new Error(\"The table specified is not a dynamic table and cannot be updated\");\n    }\n\n    if (!tableRoot.matches(Selectors.main.region)) {\n        // The table is not a dynamic table.\n        throw new Error(\"The table specified is not a dynamic table and cannot be updated\");\n    }\n\n    return true;\n};\n\n/**\n * Get the filterset data from a known dynamic table.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Object}\n */\nconst getFiltersetFromTable = tableRoot => {\n    return JSON.parse(tableRoot.dataset.tableFilters);\n};\n\n/**\n * Update the specified table based on its current values.\n *\n * @param {HTMLElement} tableRoot\n * @param {Bool} resetContent\n * @returns {Promise}\n */\nexport const refreshTableContent = (tableRoot, resetContent = false) => {\n    const filterset = getFiltersetFromTable(tableRoot);\n    addIconToContainer(tableRoot);\n\n    const pendingPromise = new Pending('core_table/dynamic:refreshTableContent');\n\n    return fetchTableData(\n        tableRoot.dataset.tableComponent,\n        tableRoot.dataset.tableHandler,\n        tableRoot.dataset.tableUniqueid,\n        {\n            sortData: JSON.parse(tableRoot.dataset.tableSortData),\n            joinType: filterset.jointype,\n            filters: filterset.filters,\n            firstinitial: tableRoot.dataset.tableFirstInitial,\n            lastinitial: tableRoot.dataset.tableLastInitial,\n            pageNumber: tableRoot.dataset.tablePageNumber,\n            pageSize: tableRoot.dataset.tablePageSize,\n            hiddenColumns: JSON.parse(tableRoot.dataset.tableHiddenColumns),\n        },\n        resetContent,\n    )\n    .then(data => {\n        const placeholder = document.createElement('div');\n        placeholder.innerHTML = data.html;\n        tableRoot.replaceWith(...placeholder.childNodes);\n\n        // Update the tableRoot.\n        return getTableFromId(tableRoot.dataset.tableUniqueid);\n    }).then(tableRoot => {\n        tableRoot.dispatchEvent(new CustomEvent(Events.tableContentRefreshed, {\n            bubbles: true,\n        }));\n\n        return tableRoot;\n    })\n    .then(tableRoot => {\n        pendingPromise.resolve();\n\n        return tableRoot;\n    });\n};\n\nexport const updateTable = (tableRoot, {\n    sortBy = null,\n    sortOrder = null,\n    filters = null,\n    firstInitial = null,\n    lastInitial = null,\n    pageNumber = null,\n    pageSize = null,\n    hiddenColumns = null,\n} = {}, refreshContent = true) => {\n    checkTableIsDynamic(tableRoot);\n\n    const pendingPromise = new Pending('core_table/dynamic:updateTable');\n    let tableConfigChanged = false;\n\n    // Update sort fields.\n    if (sortBy && sortOrder) {\n        // Always update the table if requested and there were sort fields.\n        // These fields are only ever normalised in the backend.\n        tableConfigChanged = true;\n\n        const sortData = JSON.parse(tableRoot.dataset.tableSortData);\n        sortData.unshift({\n            sortby: sortBy,\n            sortorder: parseInt(sortOrder, 10),\n        });\n        tableRoot.dataset.tableSortData = JSON.stringify(sortData);\n    }\n\n    // Update initials.\n    if (firstInitial !== null) {\n        if (tableRoot.dataset.tableFirstInitial !== firstInitial) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tableFirstInitial = firstInitial;\n    }\n\n    if (lastInitial !== null) {\n        if (tableRoot.dataset.tableLastInitial !== lastInitial) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tableLastInitial = lastInitial;\n    }\n\n    if (pageSize !== null) {\n        if (tableRoot.dataset.tablePageSize != pageSize) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tablePageSize = pageSize;\n    }\n\n    // Update filters.\n    if (filters) {\n        const filterJson = JSON.stringify(filters);\n\n        if (tableRoot.dataset.tableFilters !== filterJson) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tableFilters = filterJson;\n    }\n\n    // Reset to page 1 when table content is being altered by filtering or sorting.\n    // This ensures the table page being loaded always exists, and gives a consistent experience.\n    if (tableConfigChanged) {\n        pageNumber = 1;\n    }\n\n    // Update hidden columns.\n    if (hiddenColumns) {\n        const columnJson = JSON.stringify(hiddenColumns);\n\n        if (tableRoot.dataset.tableHiddenColumns !== columnJson) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tableHiddenColumns = columnJson;\n    }\n\n    if (pageNumber !== null) {\n        if (tableRoot.dataset.tablePageNumber != pageNumber) {\n            tableConfigChanged = true;\n        }\n\n        tableRoot.dataset.tablePageNumber = pageNumber;\n    }\n\n    // Refresh.\n    if (refreshContent && tableConfigChanged) {\n        return refreshTableContent(tableRoot)\n        .then(tableRoot => {\n            pendingPromise.resolve();\n            return tableRoot;\n        });\n    } else {\n        pendingPromise.resolve();\n        return Promise.resolve(tableRoot);\n    }\n};\n\n/**\n * Get the table dataset for the specified tableRoot, ensuring that the provided table is a dynamic table.\n *\n * @param {HTMLElement} tableRoot\n * @returns {DOMStringMap}\n */\nconst getTableData = tableRoot => {\n    checkTableIsDynamic(tableRoot);\n\n    return tableRoot.dataset;\n};\n\n/**\n * Update the specified table using the new filters.\n *\n * @param {HTMLElement} tableRoot\n * @param {Object} filters\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setFilters = (tableRoot, filters, refreshContent = true) =>\n    updateTable(tableRoot, {filters}, refreshContent);\n\n/**\n * Get the filter data for the specified table.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Object}\n */\nexport const getFilters = tableRoot => {\n    checkTableIsDynamic(tableRoot);\n\n    return getFiltersetFromTable(tableRoot);\n};\n\n/**\n * Update the sort order.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} sortBy\n * @param {Number} sortOrder\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setSortOrder = (tableRoot, sortBy, sortOrder, refreshContent = true) =>\n    updateTable(tableRoot, {sortBy, sortOrder}, refreshContent);\n\n/**\n * Set the page number.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} pageNumber\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setPageNumber = (tableRoot, pageNumber, refreshContent = true) =>\n    updateTable(tableRoot, {pageNumber}, refreshContent);\n\n/**\n * Get the current page number.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Number}\n */\nexport const getPageNumber = tableRoot => getTableData(tableRoot).tablePageNumber;\n\n/**\n * Set the page size.\n *\n * @param {HTMLElement} tableRoot\n * @param {Number} pageSize\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setPageSize = (tableRoot, pageSize, refreshContent = true) =>\n    updateTable(tableRoot, {pageSize, pageNumber: 1}, refreshContent);\n\n/**\n * Get the current page size.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Number}\n */\nexport const getPageSize = tableRoot => getTableData(tableRoot).tablePageSize;\n\n/**\n * Update the first initial to show.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} firstInitial\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setFirstInitial = (tableRoot, firstInitial, refreshContent = true) =>\n    updateTable(tableRoot, {firstInitial}, refreshContent);\n\n/**\n * Get the current first initial filter.\n *\n * @param {HTMLElement} tableRoot\n * @returns {String}\n */\nexport const getFirstInitial = tableRoot => getTableData(tableRoot).tableFirstInitial;\n\n/**\n * Update the last initial to show.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} lastInitial\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const setLastInitial = (tableRoot, lastInitial, refreshContent = true) =>\n    updateTable(tableRoot, {lastInitial}, refreshContent);\n\n/**\n * Get the current last initial filter.\n *\n * @param {HTMLElement} tableRoot\n * @returns {String}\n */\nexport const getLastInitial = tableRoot => getTableData(tableRoot).tableLastInitial;\n\n/**\n * Hide a column in the participants table.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} columnToHide\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const hideColumn = (tableRoot, columnToHide, refreshContent = true) => {\n    const hiddenColumns = JSON.parse(tableRoot.dataset.tableHiddenColumns);\n    hiddenColumns.push(columnToHide);\n\n    return updateTable(tableRoot, {hiddenColumns}, refreshContent);\n};\n\n/**\n * Make a hidden column visible in the participants table.\n *\n * @param {HTMLElement} tableRoot\n * @param {String} columnToShow\n * @param {Bool} refreshContent\n * @returns {Promise}\n */\nexport const showColumn = (tableRoot, columnToShow, refreshContent = true) => {\n    let hiddenColumns = JSON.parse(tableRoot.dataset.tableHiddenColumns);\n    hiddenColumns = hiddenColumns.filter(columnName => columnName !== columnToShow);\n\n    return updateTable(tableRoot, {hiddenColumns}, refreshContent);\n};\n\n/**\n * Reset table preferences.\n *\n * @param {HTMLElement} tableRoot\n * @returns {Promise}\n */\nconst resetTablePreferences = tableRoot => refreshTableContent(tableRoot, true);\n\n/**\n * Set up listeners to handle table updates.\n */\nexport const init = () => {\n    if (watching) {\n        // Already watching.\n        return;\n    }\n    watching = true;\n\n    document.addEventListener('click', e => {\n        const tableRoot = e.target.closest(Selectors.main.region);\n\n        if (!tableRoot) {\n            return;\n        }\n\n        const sortableLink = e.target.closest(Selectors.table.links.sortableColumn);\n        if (sortableLink) {\n            e.preventDefault();\n\n            setSortOrder(tableRoot, sortableLink.dataset.sortby, sortableLink.dataset.sortorder)\n            .catch(Notification.exception);\n        }\n\n        const firstInitialLink = e.target.closest(Selectors.initialsBar.links.firstInitial);\n        if (firstInitialLink !== null) {\n            e.preventDefault();\n\n            setFirstInitial(tableRoot, firstInitialLink.dataset.initial).catch(Notification.exception);\n        }\n\n        const lastInitialLink = e.target.closest(Selectors.initialsBar.links.lastInitial);\n        if (lastInitialLink !== null) {\n            e.preventDefault();\n\n            setLastInitial(tableRoot, lastInitialLink.dataset.initial).catch(Notification.exception);\n        }\n\n        const pageItem = e.target.closest(Selectors.paginationBar.links.pageItem);\n        if (pageItem) {\n            e.preventDefault();\n\n            setPageNumber(tableRoot, pageItem.dataset.pageNumber).catch(Notification.exception);\n        }\n\n        const hide = e.target.closest(Selectors.table.links.hide);\n        if (hide) {\n            e.preventDefault();\n\n            hideColumn(tableRoot, hide.dataset.column).catch(Notification.exception);\n        }\n\n        const show = e.target.closest(Selectors.table.links.show);\n        if (show) {\n            e.preventDefault();\n\n            showColumn(tableRoot, show.dataset.column).catch(Notification.exception);\n        }\n\n        const resetTablePreferencesLink = e.target.closest('.resettable a');\n        if (resetTablePreferencesLink) {\n            e.preventDefault();\n\n            resetTablePreferences(tableRoot).catch(Notification.exception);\n        }\n\n        const showCountLink = e.target.closest(Selectors.showCount.links.toggle);\n        if (showCountLink) {\n            e.preventDefault();\n\n            setPageSize(tableRoot, showCountLink.dataset.targetPageSize).catch(Notification.exception);\n        }\n    });\n};\n\n/**\n * Fetch the table via its table region id.\n *\n * @param {String} tableRegionId\n * @returns {HTMLElement}\n */\nexport const getTableFromId = tableRegionId => {\n    const tableRoot = document.querySelector(Selectors.main.fromRegionId(tableRegionId));\n\n\n    if (!tableRoot) {\n        // The table is not a dynamic table.\n        throw new Error(\"The table specified is not a dynamic table and cannot be updated\");\n    }\n\n    return tableRoot;\n};\n\nexport {\n    Events\n};\n"],"names":["Selectors","_interopRequireWildcard","_events","_interopRequireDefault","_pending","_notification","watching","checkTableIsDynamic","tableRoot","Error","matches","main","region","getFiltersetFromTable","JSON","parse","dataset","tableFilters","refreshTableContent","resetContent","filterset","_loadingicon","addIconToContainer","pendingPromise","Pending","default","tableComponent","tableHandler","tableUniqueid","sortData","tableSortData","joinType","jointype","filters","firstinitial","tableFirstInitial","lastinitial","tableLastInitial","pageNumber","tablePageNumber","pageSize","tablePageSize","hiddenColumns","tableHiddenColumns","then","data","placeholder","document","createElement","innerHTML","html","replaceWith","childNodes","getTableFromId","dispatchEvent","CustomEvent","Events","tableContentRefreshed","bubbles","resolve","updateTable","sortBy","sortOrder","firstInitial","lastInitial","refreshContent","tableConfigChanged","unshift","sortby","sortorder","parseInt","stringify","filterJson","columnJson","Promise","getTableData","setSortOrder","setPageNumber","setPageSize","setFirstInitial","setLastInitial","hideColumn","columnToHide","push","showColumn","columnToShow","filter","columnName","addEventListener","e","target","closest","sortableLink","table","links","sortableColumn","preventDefault","catch","Notification","exception","firstInitialLink","initialsBar","initial","lastInitialLink","pageItem","paginationBar","hide","column","show","resetTablePreferences","showCountLink","showCount","toggle","targetPageSize","tableRegionId","querySelector","fromRegionId"],"mappings":"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"}