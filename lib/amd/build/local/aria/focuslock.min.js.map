{"version":3,"sources":["../../../src/local/aria/focuslock.js"],"names":["selectors","focusable","lockRegionStack","initialFocusElementStack","finalFocusElementStack","lastFocus","ignoreFocusChanges","isLocked","lockHandler","event","lockRegion","getCurrentLockRegion","parentNode","untrapFocus","contains","target","focusFirstDescendant","document","activeElement","focusLastDescendant","focusableElements","Array","from","querySelectorAll","unshift","some","focusableElement","attemptFocus","reverse","push","isFocusable","focusTarget","tabIndex","getAttribute","disabled","nodeName","href","rel","type","focus","e","length","addLockRegionToStack","newLockRegion","currentLockRegion","element","createElement","style","position","top","left","initialNode","cloneNode","insertBefore","finalNode","nextSibling","removeLastLockRegionFromStack","pop","remove","hasTrappedRegionsInStack","trapFocus","addEventListener","originalRegionTabIndex","removeEventListener"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tab locking system.\n *\n * This is based on code and examples provided in the ARIA specification.\n * https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html\n *\n * @module     core/tablock\n * @class      tablock\n * @package    core\n * @copyright  2019 Andrew Nicols <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nconst selectors = {\n    focusable: 'input:not([type=\"hidden\"]), a[href], button, textarea, select, [tabindex]',\n};\n\nconst lockRegionStack = [];\nconst initialFocusElementStack = [];\nconst finalFocusElementStack = [];\n\nlet lastFocus = null;\nlet ignoreFocusChanges = false;\nlet isLocked = false;\n\n/**\n * The lock handler.\n *\n * This is the item that does a majority of the work.\n * The overall logic from this comes from the examles in the WCAG guidelines.\n *\n * The general idea is that if the focus is not held within by an Element within the lock region, then we replace focus\n * on the first element in the lock region. If the first element is the element previously selected prior to the\n * user-initiated focus change, then instead jump to the last element in the lock region.\n *\n * This gives us a solution which supports focus locking of any kind, which loops in both directions, and which\n * prevents the lock from escaping the modal entirely.\n *\n * @param {Event} event The event from the focus change\n */\nconst lockHandler = event => {\n    if (ignoreFocusChanges) {\n        // The focus change was made by an internal call to set focus.\n        return;\n    }\n\n    const lockRegion = getCurrentLockRegion();\n\n    if (!lockRegion.parentNode) {\n        // The lock region does not exist.\n        // Perhaps it was removed without being untrapped.\n        untrapFocus();\n    }\n\n    if (lockRegion.contains(event.target)) {\n        lastFocus = event.target;\n    } else {\n        focusFirstDescendant();\n        if (lastFocus == document.activeElement) {\n            focusLastDescendant();\n        }\n        lastFocus = document.activeElement;\n    }\n};\n\n/**\n * Focus the first descendant of the current lock region.\n *\n * @returns {Bool} Whether a node was focused\n */\nconst focusFirstDescendant = () => {\n    const lockRegion = getCurrentLockRegion();\n\n    // Grab all elements in the lock region and attempt to focus each element until one is focused.\n    // We can capture most of this in the query selector, but some cases may still reject focus.\n    // For example, a disabled text area cannot be focused, and it becomes difficult to provide a decent query selector\n    // to capture this.\n    // The use of Array.some just ensures that we stop as soon as we have a successful focus.\n    const focusableElements = Array.from(lockRegion.querySelectorAll(selectors.focusable));\n\n    // The lock region itself may be focusable. This is particularly true on Moodle's older dialogues.\n    // We must include it in the calculation of descendants to ensure that looping works correctly.\n    focusableElements.unshift(lockRegion);\n    return focusableElements.some(focusableElement => attemptFocus(focusableElement));\n};\n\n/**\n * Focus the last descendant of the current lock region.\n *\n * @returns {Bool} Whether a node was focused\n */\nconst focusLastDescendant = () => {\n    const lockRegion = getCurrentLockRegion();\n\n    // Grab all elements in the lock region, reverse them, and attempt to focus each element until one is focused.\n    // We can capture most of this in the query selector, but some cases may still reject focus.\n    // For example, a disabled text area cannot be focused, and it becomes difficult to provide a decent query selector\n    // to capture this.\n    // The use of Array.some just ensures that we stop as soon as we have a successful focus.\n    const focusableElements = Array.from(lockRegion.querySelectorAll(selectors.focusable)).reverse();\n\n    // The lock region itself may be focusable. This is particularly true on Moodle's older dialogues.\n    // We must include it in the calculation of descendants to ensure that looping works correctly.\n    focusableElements.push(lockRegion);\n    return focusableElements.some(focusableElement => attemptFocus(focusableElement));\n};\n\n/**\n * Check whether the supplied focusTarget is actually focusable.\n * There are cases where a normally focusable element can reject focus.\n *\n * Note: This example is a wholesale copy of the WCAG example.\n *\n * @param {HTMLElement} focusTarget\n * @returns {Bool}\n */\nconst isFocusable = focusTarget => {\n    if (focusTarget.tabIndex > 0 || (focusTarget.tabIndex === 0 && focusTarget.getAttribute('tabIndex') !== null)) {\n        return true;\n    }\n\n    if (focusTarget.disabled) {\n        return false;\n    }\n\n    switch (focusTarget.nodeName) {\n        case 'A':\n            return !!focusTarget.href && focusTarget.rel != 'ignore';\n        case 'INPUT':\n            return focusTarget.type != 'hidden' && focusTarget.type != 'file';\n        case 'BUTTON':\n        case 'SELECT':\n        case 'TEXTAREA':\n            return true;\n        default:\n            return false;\n    }\n};\n\n/**\n * Attempt to focus the supplied focusTarget.\n *\n * Note: This example is a heavily inspired by the WCAG example.\n *\n * @param {HTMLElement} focusTarget\n * @returns {Bool} Whether focus was successful o rnot.\n */\nconst attemptFocus = focusTarget => {\n    if (!isFocusable(focusTarget)) {\n        return false;\n    }\n\n    // The ignoreFocusChanges variable prevents the focus event handler from interfering and entering a fight with itself.\n    ignoreFocusChanges = true;\n\n    try {\n        focusTarget.focus();\n    } catch (e) {\n        // Ignore failures. We will just try to focus the next element in the list.\n        // eslint-disable-line\n    }\n\n    ignoreFocusChanges = false;\n\n    // If focus was successful the activeElement will be the one we focused.\n    return (document.activeElement === focusTarget);\n};\n\n/**\n * Get the current lock region from the top of the stack.\n *\n * @returns {HTMLElement}\n */\nconst getCurrentLockRegion = () => {\n    return lockRegionStack[lockRegionStack.length - 1];\n};\n\n/**\n * Add a new lock region to the stack.\n *\n * @param {HTMLElement} newLockRegion\n */\nconst addLockRegionToStack = newLockRegion => {\n    if (newLockRegion === getCurrentLockRegion()) {\n        return;\n    }\n\n    lockRegionStack.push(newLockRegion);\n    const currentLockRegion = getCurrentLockRegion();\n\n    // Append an empty div which can be focused just outside of the item locked.\n    // This locks tab focus to within the tab region, and does not allow it to extend back into the window by\n    // guaranteeing the existence of a tabable item after the lock region which can be focused but which will be caught\n    // by the handler.\n    const element = document.createElement('div');\n    element.tabIndex = 0;\n    element.style.position = 'fixed';\n    element.style.top = 0;\n    element.style.left = 0;\n\n    const initialNode = element.cloneNode();\n    currentLockRegion.parentNode.insertBefore(initialNode, currentLockRegion);\n    initialFocusElementStack.push(initialNode);\n\n    const finalNode = element.cloneNode();\n    currentLockRegion.parentNode.insertBefore(finalNode, currentLockRegion.nextSibling);\n    finalFocusElementStack.push(finalNode);\n};\n\n/**\n * Remove the top lock region from the stack.\n */\nconst removeLastLockRegionFromStack = () => {\n    // Take the top element off the stack, and replce the current lockRegion value.\n    lockRegionStack.pop();\n\n    const finalNode = finalFocusElementStack.pop();\n    if (finalNode) {\n        // The final focus element may have been removed if it was part of a parent item.\n        finalNode.remove();\n    }\n\n    const initialNode = initialFocusElementStack.pop();\n    if (initialNode) {\n        // The initial focus element may have been removed if it was part of a parent item.\n        initialNode.remove();\n    }\n};\n\n/**\n * Whether any region is left in the stack.\n *\n * @return {Bool}\n */\nconst hasTrappedRegionsInStack = () => {\n    return !!lockRegionStack.length;\n};\n\n/**\n * Start trapping the focus and lock it to the specified newLockRegion.\n *\n * @param {HTMLElement} newLockRegion The container to lock focus to\n */\nexport const trapFocus = newLockRegion => {\n    // Update the lock region stack.\n    // This allows us to support nesting.\n    addLockRegionToStack(newLockRegion);\n\n    if (!isLocked) {\n        // Add the focus handler.\n        document.addEventListener('focus', lockHandler, true);\n    }\n\n    // Attempt to focus on the first item in the lock region.\n    if (!focusFirstDescendant()) {\n        const currentLockRegion = getCurrentLockRegion();\n\n        // No focusable descendants found in the region yet.\n        // This can happen when the region is locked before content is generated.\n        // Focus on the region itself for now.\n        const originalRegionTabIndex = currentLockRegion.tabIndex;\n        currentLockRegion.tabIndex = 0;\n        attemptFocus(currentLockRegion);\n        currentLockRegion.tabIndex = originalRegionTabIndex;\n    }\n\n    // Keep track of the last item focused.\n    lastFocus = document.activeElement;\n\n    isLocked = true;\n};\n\n/**\n * Stop trapping the focus.\n */\nexport const untrapFocus = () => {\n    // Remove the top region from the stack.\n    removeLastLockRegionFromStack();\n\n    if (hasTrappedRegionsInStack()) {\n        // The focus manager still has items in the stack.\n        return;\n    }\n\n    document.removeEventListener('focus', lockHandler, true);\n\n    lastFocus = null;\n    ignoreFocusChanges = false;\n    isLocked = false;\n};\n"],"file":"focuslock.min.js"}