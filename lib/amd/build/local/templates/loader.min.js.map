{"version":3,"file":"loader.min.js","sources":["../../../src/local/templates/loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport $ from 'jquery';\nimport * as ajax from 'core/ajax';\nimport * as str from 'core/str';\nimport * as config from 'core/config';\nimport mustache from 'core/mustache';\nimport * as storage from 'core/localstorage';\nimport * as notification from 'core/notification';\nimport {getNormalisedComponent} from 'core/utils';\n\n/**\n * Template Loader.\n *\n * @module     core/local/templates/loader\n * @copyright  2023 Andrew Lyons <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      4.2\n */\nexport default class Loader {\n    /** @var {String} themeName for the current render */\n    currentThemeName = '';\n\n    /** @var {Number} uniqInstances Count of times this constructor has been called. */\n    static uniqInstances = 0;\n\n    /** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\n    static loadTemplateBuffer = [];\n\n    /** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\n    static isLoadingTemplates = false;\n\n    /** @var {Object} iconSystem - Object extending core/iconsystem */\n    static iconSystem = {};\n\n    /** @var {Array} disallowedNestedHelpers - List of helpers that can't be called within other helpers */\n    static disallowedNestedHelpers = [\n        'js',\n    ];\n\n    /** @var {String[]} templateCache - Cache of already loaded template strings */\n    static templateCache = {};\n\n    /** @var {Promise[]} templatePromises - Cache of already loaded template promises */\n    static templatePromises = {};\n\n    static getSearchKey (theme, templateName) {\n        return `${theme}/${templateName}`;\n    }\n\n    /** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\n    static cachePartialPromises = [];\n\n    /**\n     * Load a template.\n     *\n     * @method getTemplate\n     * @private\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {string} [themeName=config.theme] - The theme to load the template from\n     * @return {Promise} JQuery promise object resolved when the template has been fetched.\n     */\n    static getTemplate (templateName, themeName = config.theme) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n\n        // If we haven't already seen this template then buffer it.\n        const cachedPromise = this.getTemplatePromiseFromCache(searchKey);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n\n        // Check the buffer to see if this template has already been added.\n        var existingBufferRecords = this.loadTemplateBuffer.filter(function (record) {\n            return record.searchKey == searchKey;\n        });\n        if (existingBufferRecords.length) {\n            // This template is already in the buffer so just return the existing\n            // promise. No need to add it to the buffer again.\n            return existingBufferRecords[0].deferred.promise();\n        }\n\n        // This is the first time this has been requested so let's add it to the buffer\n        // to be loaded.\n        var parts = templateName.split('/');\n        var component = getNormalisedComponent(parts.shift());\n        var name = parts.join('/');\n        var deferred = $.Deferred();\n\n        // Add this template to the buffer to be loaded.\n        this.loadTemplateBuffer.push({\n            component: component,\n            name: name,\n            theme: themeName,\n            searchKey: searchKey,\n            deferred: deferred\n        });\n\n        // We know there is at least one thing in the buffer so kick off a processing run.\n        this.processLoadTemplateBuffer();\n        return deferred.promise();\n    }\n\n    /**\n     * Prefetch a set of templates without rendering them.\n     *\n     * @param {Array} templateNames The list of templates to fetch\n     * @param {String} themeName\n     */\n    static prefetchTemplates (templateNames, themeName) {\n        templateNames.forEach((templateName) => this.prefetchTemplate(templateName, themeName));\n    }\n\n    static prefetchTemplate (templateName, themeName) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n\n        // If we haven't already seen this template then buffer it.\n        if (this.getTemplatePromiseFromCache(searchKey)) {\n            return;\n        }\n\n        // Check the buffer to see if this template has already been added.\n        var existingBufferRecords = this.loadTemplateBuffer.filter(function (record) {\n            return record.searchKey == searchKey;\n        });\n\n        if (existingBufferRecords.length) {\n            // This template is already in the buffer so just return the existing promise.\n            // No need to add it to the buffer again.\n            return;\n        }\n\n        // This is the first time this has been requested so let's add it to the buffer to be loaded.\n        var parts = templateName.split('/');\n        var component = getNormalisedComponent(parts.shift());\n        var name = parts.join('/');\n\n        // Add this template to the buffer to be loaded.\n        this.loadTemplateBuffer.push({\n            component: component,\n            name: name,\n            theme: themeName,\n            searchKey: searchKey,\n            deferred: $.Deferred(),\n        });\n\n        this.processLoadTemplateBuffer();\n    }\n\n    /**\n     * Load a partial from the cache or ajax.\n     *\n     * @method partialHelper\n     * @private\n     * @param {string} name The partial name to load.\n     * @param {string} [themeName = config.theme] The theme to load the partial from.\n     * @return {string}\n     */\n    static partialHelper (name, themeName = config.theme) {\n        const searchKey = this.getSearchKey(themeName, name);\n\n        if (!(searchKey in this.templateCache)) {\n            notification.exception(new Error('Failed to pre-fetch the template: ' + name));\n        }\n\n        return this.templateCache[searchKey];\n    }\n\n    /**\n     * Scan a template source for partial tags and return a list of the found partials.\n     *\n     * @method scanForPartials\n     * @private\n     * @param {string} templateSource - source template to scan.\n     * @return {Array} List of partials.\n     */\n    static scanForPartials (templateSource) {\n        const tokens = mustache.parse(templateSource);\n        const partials = [];\n\n        const findPartial = (tokens, partials) => {\n            let i;\n            for (i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                if (token[0] == '>' || token[0] == '<') {\n                    partials.push(token[1]);\n                }\n                if (token.length > 4) {\n                    findPartial(token[4], partials);\n                }\n            }\n        };\n\n        findPartial(tokens, partials);\n\n        return partials;\n    }\n\n    /**\n     * Load a template and scan it for partials. Recursively fetch the partials.\n     *\n     * @method cachePartials\n     * @private\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {string} [themeName=config.theme]\n     * @param {Array} parentage - A list of requested partials in this render chain.\n     * @return {Promise} JQuery promise object resolved when all partials are in the cache.\n     */\n    static cachePartials (templateName, themeName = config.theme, parentage = []) {\n        const searchKey = this.getSearchKey(this.currentThemeName, templateName);\n\n        if (searchKey in this.cachePartialPromises) {\n            return this.cachePartialPromises[searchKey];\n        }\n\n        // This promise will not be resolved until all child partials are also resolved and ready.\n        // We create it here to allow us to check for recursive inclusion of templates.\n        // Keep track of the requested partials in this chain.\n        parentage = parentage || [searchKey];\n\n        this.cachePartialPromises[searchKey] = $.Deferred();\n\n        this.getTemplate(templateName, themeName)\n            .then(function (templateSource) {\n                var partials = this.scanForPartials(templateSource);\n                var uniquePartials = partials.filter(function (partialName) {\n                    // Check for recursion.\n\n                    if (parentage.indexOf(this.currentThemeName + '/' + partialName) >= 0) {\n                        // Ignore templates which include a parent template already requested in the current chain.\n                        return false;\n                    }\n\n                    // Ignore templates that include themselves.\n                    return partialName != templateName;\n                }.bind(this));\n\n                // Fetch any partial which has not already been fetched.\n                var fetchThemAll = uniquePartials.map(function (partialName) {\n                    parentage.push(this.currentThemeName + '/' + partialName);\n                    return this.cachePartials(partialName, themeName, parentage);\n                }.bind(this));\n\n                // Resolve the templateName promise when all of the children are resolved.\n                return $.when.apply($, fetchThemAll)\n                    .then(function () {\n                        return Loader.cachePartialPromises[searchKey].resolve(templateSource);\n                    });\n            }.bind(this))\n            .catch(Loader.cachePartialPromises[searchKey].reject);\n\n        return this.cachePartialPromises[searchKey];\n    }\n\n    /**\n     * Take all of the templates waiting in the buffer and load them from the server\n     * or from the cache.\n     *\n     * All of the templates that need to be loaded from the server will be batched up\n     * and sent in a single network request.\n     */\n    static processLoadTemplateBuffer () {\n        if (!this.loadTemplateBuffer.length) {\n            return;\n        }\n\n        if (this.isLoadingTemplates) {\n            return;\n        }\n\n        this.isLoadingTemplates = true;\n        // Grab any templates waiting in the buffer.\n        var templatesToLoad = this.loadTemplateBuffer.slice();\n        // This will be resolved with the list of promises for the server request.\n        var serverRequestsDeferred = $.Deferred();\n        var requests = [];\n        // Get a list of promises for each of the templates we need to load.\n        var templatePromises = templatesToLoad.map(function (templateData) {\n            var component = getNormalisedComponent(templateData.component);\n            var name = templateData.name;\n            var searchKey = templateData.searchKey;\n            var theme = templateData.theme;\n            var templateDeferred = templateData.deferred;\n            var promise = null;\n\n            // Double check to see if this template happened to have landed in the\n            // cache as a dependency of an earlier template.\n            var cachedPromise = Loader.getTemplatePromiseFromCache(searchKey);\n            if (cachedPromise) {\n                // We've seen this template so immediately resolve the existing promise.\n                promise = cachedPromise;\n            } else {\n                // We haven't seen this template yet so we need to request it from\n                // the server.\n                requests.push({\n                    methodname: 'core_output_load_template_with_dependencies',\n                    args: {\n                        component: component,\n                        template: name,\n                        themename: theme,\n                        lang: $('html').attr('lang').replace(/-/g, '_')\n                    }\n                });\n                // Remember the index in the requests list for this template so that\n                // we can get the appropriate promise back.\n                var index = requests.length - 1;\n\n                // The server deferred will be resolved with a list of all of the promises\n                // that were sent in the order that they were added to the requests array.\n                promise = serverRequestsDeferred.promise()\n                    .then(function (promises) {\n                        // The promise for this template will be the one that matches the index\n                        // for it's entry in the requests array.\n                        //\n                        // Make sure the promise is added to the promises cache for this template\n                        // search key so that we don't request it again.\n                        templatePromises[searchKey] = promises[index].then(function (response) {\n                            var templateSource = null;\n\n                            // Process all of the template dependencies for this template and add\n                            // them to the caches so that we don't request them again later.\n                            response.templates.forEach(function (data) {\n                                data.component = getNormalisedComponent(data.component);\n                                // Generate the search key for this template in the response so that we\n                                // can add it to the caches.\n                                var tempSearchKey = [theme, data.component, data.name].join('/');\n                                // Cache all of the dependent templates because we'll need them to render\n                                // the requested template.\n                                Loader.templateCache[tempSearchKey] = data.value;\n\n                                if (M.cfg.templaterev > 0) {\n                                    // The template cache is enabled - set the value there.\n                                    storage.set('core_template/' + M.cfg.templaterev + ':' + tempSearchKey, data.value);\n                                }\n\n                                if (data.component == component && data.name == name) {\n                                    // This is the original template that was requested so remember it to return.\n                                    templateSource = data.value;\n                                }\n                            });\n\n                            if (response.strings.length) {\n                                // If we have strings that the template needs then warm the string cache\n                                // with them now so that we don't need to re-fetch them.\n                                str.cache_strings(response.strings.map(function (data) {\n                                    return {\n                                        component: getNormalisedComponent(data.component),\n                                        key: data.name,\n                                        value: data.value\n                                    };\n                                }));\n                            }\n\n                            // Return the original template source that the user requested.\n                            return templateSource;\n                        });\n\n                        return templatePromises[searchKey];\n                    });\n            }\n\n            return promise\n                .then(function (source) {\n                    // When we've successfully loaded the template then resolve the deferred\n                    // in the buffer so that all of the calling code can proceed.\n                    return templateDeferred.resolve(source);\n                })\n                .catch(function (error) {\n                    // If there was an error loading the template then reject the deferred\n                    // in the buffer so that all of the calling code can proceed.\n                    templateDeferred.reject(error);\n                    // Rethrow for anyone else listening.\n                    throw error;\n                });\n        });\n\n        if (requests.length) {\n            // We have requests to send so resolve the deferred with the promises.\n            serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, M.cfg.templaterev));\n        } else {\n            // Nothing to load so we can resolve our deferred.\n            serverRequestsDeferred.resolve();\n        }\n\n        // Once we've finished loading all of the templates then recurse to process\n        // any templates that may have been added to the buffer in the time that we\n        // were fetching.\n        $.when.apply(null, templatePromises)\n            .then(function () {\n                // Remove the templates we've loaded from the buffer.\n                Loader.loadTemplateBuffer.splice(0, templatesToLoad.length);\n                Loader.isLoadingTemplates = false;\n                Loader.processLoadTemplateBuffer();\n                return;\n            })\n            .catch(function () {\n                // Remove the templates we've loaded from the buffer.\n                Loader.loadTemplateBuffer.splice(0, templatesToLoad.length);\n                Loader.isLoadingTemplates = false;\n                Loader.processLoadTemplateBuffer();\n            });\n    }\n\n    /**\n     * Search the various caches for a template promise for the given search key.\n     * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\n     *\n     * If the template is found in any of the caches it will populate the other caches with\n     * the same data as well.\n     *\n     * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\n     * @returns {Object|null} jQuery promise resolved with the template source\n     */\n    static getTemplatePromiseFromCache (searchKey) {\n        // First try the cache of promises.\n        if (searchKey in this.templatePromises) {\n            return this.templatePromises[searchKey];\n        }\n\n        // Check the module cache.\n        if (searchKey in this.templateCache) {\n            // Add this to the promises cache for future.\n            this.templatePromises[searchKey] = $.Deferred().resolve(this.templateCache[searchKey]).promise();\n            return this.templatePromises[searchKey];\n        }\n\n        if (config.templaterev <= 0) {\n            // Template caching is disabled. Do not store in persistent storage.\n            return null;\n        }\n\n        // Now try local storage.\n        const cached = storage.get('core_template/' + M.cfg.templaterev + ':' + searchKey);\n        if (cached) {\n            // Add this to the module cache for future.\n            this.templateCache[searchKey] = cached;\n            // Add this to the promises cache for future.\n            this.templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\n            return this.templatePromises[searchKey];\n        }\n\n        return null;\n    }\n}\n"],"names":["Loader","theme","templateName","themeName","config","searchKey","this","getSearchKey","cachedPromise","getTemplatePromiseFromCache","existingBufferRecords","loadTemplateBuffer","filter","record","length","deferred","promise","parts","split","component","shift","name","join","$","Deferred","push","processLoadTemplateBuffer","templateNames","forEach","prefetchTemplate","templateCache","notification","exception","Error","templateSource","tokens","mustache","parse","partials","findPartial","i","token","parentage","currentThemeName","cachePartialPromises","getTemplate","then","fetchThemAll","scanForPartials","partialName","indexOf","bind","map","cachePartials","when","apply","resolve","catch","reject","isLoadingTemplates","templatesToLoad","slice","serverRequestsDeferred","requests","templatePromises","templateData","templateDeferred","methodname","args","template","themename","lang","attr","replace","index","promises","response","templates","data","tempSearchKey","value","M","cfg","templaterev","storage","set","strings","str","cache_strings","key","source","error","ajax","call","splice","cached","get"],"mappings":"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"}