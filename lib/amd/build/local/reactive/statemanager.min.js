define ("core/local/reactive/statemanager",["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.default=void 0;_exports.default=class{constructor(dispatchEvent,target){this.dispatchEvent=dispatchEvent;this.target=null!==target&&void 0!==target?target:document;this.readonly=!1;this.eventsToPublish=[];this.updateTypes={create:this.defaultCreate.bind(this),update:this.defaultUpdate.bind(this),delete:this.defaultDelete.bind(this),put:this.defaultPut.bind(this),override:this.defaultOverride.bind(this),remove:this.defaultRemove.bind(this),prepareFields:this.defaultPrepareFields.bind(this)};this.initialPromise=new Promise(resolve=>{this.target.addEventListener("state:loaded",event=>{resolve(event.detail.state)})})}setInitialState(initialState){if(this.state!==void 0){throw Error("Initial state can only be initialized ones")}const state=new Proxy({},new Handler("state",this,!0));for(const[prop,propValue]of Object.entries(initialState)){state[prop]=propValue}this.state=state;this.readonly=!0;this.dispatchEvent({action:"state:loaded",state:this.state},this.target)}getInitialPromise(){return this.initialPromise}setReadOnly(readonly){this.readonly=readonly;let mode="off";if(this.readonly){mode="on";this._publishEvents()}this.dispatchEvent({action:"readmode:".concat(mode),state:this.state,element:null},this.target)}addUpdateTypes(newFunctions){for(const[updateType,updateFunction]of Object.entries(newFunctions)){if("function"==typeof updateFunction){this.updateTypes[updateType]=updateFunction.bind(newFunctions)}}}processUpdates(updates,updateTypes){if(!Array.isArray(updates)){throw Error("State updates must be an array")}this.setReadOnly(!1);updates.forEach(update=>{if(update.name===void 0){throw Error("Missing state update name")}this.processUpdate(update.name,update.action,update.fields,updateTypes)});this.setReadOnly(!0)}processUpdate(updateName,action,fields,updateTypes){var _action,_updateTypes$action,_updateTypes$prepareF;if(!fields){throw Error("Missing state update fields")}if(updateTypes===void 0){updateTypes={}}action=null!==(_action=action)&&void 0!==_action?_action:"update";const method=null!==(_updateTypes$action=updateTypes[action])&&void 0!==_updateTypes$action?_updateTypes$action:this.updateTypes[action];if(method===void 0){throw Error("Unkown update action ".concat(action))}const prepareFields=null!==(_updateTypes$prepareF=updateTypes.prepareFields)&&void 0!==_updateTypes$prepareF?_updateTypes$prepareF:this.updateTypes.prepareFields;method(this,updateName,prepareFields(this,updateName,fields))}defaultPrepareFields(stateManager,updateName,fields){return fields}defaultCreate(stateManager,updateName,fields){let state=stateManager.state;if(state[updateName]instanceof StateMap){state[updateName].add(fields);return}state[updateName]=fields}defaultDelete(stateManager,updateName,fields){let current=stateManager.get(updateName,fields.id);if(!current){throw Error("Inexistent ".concat(updateName," ").concat(fields.id))}let state=stateManager.state;if(state[updateName]instanceof StateMap){state[updateName].delete(fields.id);return}delete state[updateName]}defaultRemove(stateManager,updateName,fields){let current=stateManager.get(updateName,fields.id);if(!current){return}let state=stateManager.state;if(state[updateName]instanceof StateMap){state[updateName].delete(fields.id);return}delete state[updateName]}defaultUpdate(stateManager,updateName,fields){let current=stateManager.get(updateName,fields.id);if(!current){throw Error("Inexistent ".concat(updateName," ").concat(fields.id))}for(const[fieldName,fieldValue]of Object.entries(fields)){current[fieldName]=fieldValue}}defaultPut(stateManager,updateName,fields){let current=stateManager.get(updateName,fields.id);if(current){for(const[fieldName,fieldValue]of Object.entries(fields)){current[fieldName]=fieldValue}}else{let state=stateManager.state;if(state[updateName]instanceof StateMap){state[updateName].add(fields);return}state[updateName]=fields}}defaultOverride(stateManager,updateName,fields){let current=stateManager.get(updateName,fields.id);if(current){for(const[fieldName]of Object.entries(current)){if(fields[fieldName]===void 0){delete current[fieldName]}}for(const[fieldName,fieldValue]of Object.entries(fields)){current[fieldName]=fieldValue}}else{let state=stateManager.state;if(state[updateName]instanceof StateMap){state[updateName].add(fields);return}state[updateName]=fields}}get(name,id){const state=this.state;let current=state[name];if(current instanceof StateMap){if(id===void 0){throw Error("Missing id for ".concat(name," state update"))}current=state[name].get(id)}return current}registerStateAction(field,prop,action,data){let parentAction="updated";if(null!==prop){this.eventsToPublish.push({eventName:"".concat(field,".").concat(prop,":").concat(action),eventData:data,action})}else{parentAction=action}if(data.id!==void 0){if(null!==prop){this.eventsToPublish.push({eventName:"".concat(field,"[").concat(data.id,"].").concat(prop,":").concat(action),eventData:data,action})}this.eventsToPublish.push({eventName:"".concat(field,"[").concat(data.id,"]:").concat(parentAction),eventData:data,action:parentAction})}this.eventsToPublish.push({eventName:"".concat(field,":").concat(parentAction),eventData:data,action:parentAction});this.eventsToPublish.push({eventName:"state:updated",eventData:data,action:"updated"})}_publishEvents(){const fieldChanges=this.eventsToPublish;this.eventsToPublish=[];this.dispatchEvent({action:"transaction:start",state:this.state,element:null,changes:fieldChanges},this.target);fieldChanges.sort((a,b)=>{var _weights$a$action,_weights$b$action;const weights={created:0,updated:1,deleted:2},aweight=null!==(_weights$a$action=weights[a.action])&&void 0!==_weights$a$action?_weights$a$action:0,bweight=null!==(_weights$b$action=weights[b.action])&&void 0!==_weights$b$action?_weights$b$action:0;if(aweight===bweight){return a.eventName.length-b.eventName.length}return aweight-bweight});let publishedEvents=new Set;fieldChanges.forEach(event=>{var _event$eventData$id;const eventkey="".concat(event.eventName,".").concat(null!==(_event$eventData$id=event.eventData.id)&&void 0!==_event$eventData$id?_event$eventData$id:0);if(!publishedEvents.has(eventkey)){this.dispatchEvent({action:event.eventName,state:this.state,element:event.eventData},this.target);publishedEvents.add(eventkey)}});this.dispatchEvent({action:"transaction:end",state:this.state,element:null},this.target)}};class Handler{constructor(name,stateManager,proxyValues){this.name=name;this.stateManager=stateManager;this.proxyValues=null!==proxyValues&&void 0!==proxyValues?proxyValues:!1}set(obj,prop,value,receiver){if(this.stateManager.readonly){throw new Error("State locked. Use mutations to change ".concat(prop," value in ").concat(this.name,"."))}if(JSON.stringify(obj[prop])===JSON.stringify(value)){return!0}const action=obj[prop]!==void 0?"updated":"created";if(this.proxyValues){if(Array.isArray(value)){obj[prop]=new StateMap(prop,this.stateManager).loadValues(value)}else{obj[prop]=new Proxy(value,new Handler(prop,this.stateManager))}}else{obj[prop]=value}if(this.stateManager.state===void 0){return!0}this.stateManager.registerStateAction(this.name,prop,action,receiver);return!0}deleteProperty(obj,prop){if(this.stateManager.readonly){throw new Error("State locked. Use mutations to delete ".concat(prop," in ").concat(this.name,"."))}if(prop in obj){delete obj[prop];this.stateManager.registerStateAction(this.name,prop,"deleted",obj)}return!0}}class StateMap extends Map{constructor(name,stateManager,iterable){super(iterable);this.name=name;this.stateManager=stateManager}set(key,value){if(this.stateManager.readonly){throw new Error("State locked. Use mutations to change ".concat(key," value in ").concat(this.name,"."))}key=this.normalizeKey(key);this.checkValue(value);if(key===void 0||null===key){throw Error("State lists keys cannot be null or undefined")}if(this.normalizeKey(value.id)!==key){throw new Error("State error: ".concat(this.name," list element ID (").concat(value.id,") and key (").concat(key,") mismatch"))}const action=super.has(key)?"updated":"created",result=super.set(key,new Proxy(value,new Handler(this.name,this.stateManager)));if(this.stateManager.state===void 0){return result}this.stateManager.registerStateAction(this.name,null,action,super.get(key));return result}checkValue(value){if("object"===!typeof value&&null!==value){throw Error("State lists can contain objects only")}if(value.id===void 0){throw Error("State lists elements must contain at least an id attribute")}}normalizeKey(key){return(key+"").valueOf()}add(value){this.checkValue(value);return this.set(value.id,value)}get(key){return super.get(this.normalizeKey(key))}has(key){return super.has(this.normalizeKey(key))}delete(key){key=this.normalizeKey(key);if(this.stateManager.readonly){throw new Error("State locked. Use mutations to change ".concat(key," value in ").concat(this.name,"."))}const previous=super.get(key),result=super.delete(key);if(!result){return result}this.stateManager.registerStateAction(this.name,null,"deleted",previous);return result}toJSON(){let result=[];this.forEach(value=>{result.push(value)});return result}loadValues(values){values.forEach(data=>{this.checkValue(data);let key=data.id,newvalue=new Proxy(data,new Handler(this.name,this.stateManager));this.set(key,newvalue)});return this}}return _exports.default});
//# sourceMappingURL=statemanager.min.js.map
