{"version":3,"sources":["../../../src/local/reactive/reactive.js"],"names":["pendingCount","constructor","description","eventName","eventDispatch","Error","name","target","document","createTextNode","stateManager","StateManager","watchers","Map","components","Set","mutations","addEventListener","callWatchersHandler","bind","pendingState","Pending","state","setInitialState","M","reactive","registerNewInstance","event","dispatchEvent","CustomEvent","detail","action","bubbles","stateData","resolve","addMutations","newFunctions","init","mutation","mutationFunction","Object","entries","setMutations","manager","get","id","getInitialStatePromise","getInitialPromise","registerComponent","component","componentName","dispatchSuccess","dispatchFail","dispatchRegistrationSuccess","dispatchRegistrationFail","has","pendingPromise","listeners","handlers","getWatchers","forEach","watch","handler","listener","currentFocus","activeElement","apply","body","contains","focus","push","stateReady","then","catch","reason","log","error","set","add","unregisterComponent","delete","removeEventListener","dispatch","actionName","charAt","params","setReadOnly"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A generic single state reactive module.\n *\n * @module     core/reactive/local/reactive/reactive\n * @class     core/reactive/local/reactive/reactive\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport log from 'core/log';\nimport StateManager from 'core/local/reactive/statemanager';\nimport Pending from 'core/pending';\n\n// Count the number of pending operations done to ensure we have a unique id for each one.\nlet pendingCount = 0;\n\n/**\n * Set up general reactive class to create a single state application with components.\n *\n * The reactive class is used for registering new UI components and manage the access to the state values\n * and mutations.\n *\n * When a new reactive instance is created, it will contain an empty state and and empty mutations\n * lists. When the state data is ready, the initial state can be loaded using the \"setInitialState\"\n * method. This will protect the state from writing and will trigger all the components \"stateReady\"\n * methods.\n *\n * State can only be altered by mutations. To replace all the mutations with a specific class,\n * use \"setMutations\" method. If you need to just add some new mutation methods, use \"addMutations\".\n *\n * To register new components into a reactive instance, use \"registerComponent\".\n *\n * Inside a component, use \"dispatch\" to invoke a mutation on the state (components can only access\n * the state in read only mode).\n */\nexport default class {\n\n    /**\n     * The component descriptor data structure.\n     *\n     * @typedef {object} description\n     * @property {string} eventName the custom event name used for state changed events\n     * @property {Function} eventDispatch the state update event dispatch function\n     * @property {Element} [target] the target of the event dispatch. If not passed a fake element will be created\n     * @property {Object} [mutations] an object with state mutations functions\n     * @property {Object} [state] an object to initialize the state.\n     */\n\n    /**\n     * Create a basic reactive manager.\n     *\n     * Note that if your state is not async loaded, you can pass directly on creation by using the\n     * description.state attribute. However, this will initialize the state, this means\n     * setInitialState will throw an exception because the state is already defined.\n     *\n     * @param {description} description reactive manager description.\n     */\n    constructor(description) {\n\n        if (description.eventName === undefined || description.eventDispatch === undefined) {\n            throw new Error(`Reactivity event required`);\n        }\n\n        if (description.name !== undefined) {\n            this.name = description.name;\n        }\n\n        // Each reactive instance has its own element anchor to propagate state changes internally.\n        // By default the module will create a fake DOM element to target custom events but\n        // if all reactive components is constrait to a single element, this can be passed as\n        // target in the description.\n        this.target = description.target ?? document.createTextNode(null);\n\n        this.eventName = description.eventName;\n        this.eventDispatch = description.eventDispatch;\n\n        // State manager is responsible for dispatch state change events when a mutation happens.\n        this.stateManager = new StateManager(this.eventDispatch, this.target);\n\n        // An internal registry of watchers and components.\n        this.watchers = new Map([]);\n        this.components = new Set([]);\n\n        // Mutations can be overridden later using setMutations method.\n        this.mutations = description.mutations ?? {};\n\n        // Register the event to alert watchers when specific state change happens.\n        this.target.addEventListener(this.eventName, this.callWatchersHandler.bind(this));\n\n        // Add a pending operation waiting for the initial state.\n        this.pendingState = new Pending(`core/reactive:registerInstance${pendingCount++}`);\n\n        // Set initial state if we already have it.\n        if (description.state !== undefined) {\n            this.setInitialState(description.state);\n        }\n\n        // Check if we have a debug instance to register the instance.\n        if (M.reactive !== undefined) {\n            M.reactive.registerNewInstance(this);\n        }\n    }\n\n    /**\n     * State changed listener.\n     *\n     * This function take any state change and send it to the proper watchers.\n     *\n     * To prevent internal state changes from colliding with other reactive instances, only the\n     * general \"state changed\" is triggered at document level. All the internal changes are\n     * triggered at private target level without bubbling. This way any reactive instance can alert\n     * only its own watchers.\n     *\n     * @param {CustomEvent} event\n     */\n    callWatchersHandler(event) {\n        // Execute any registered component watchers.\n        this.target.dispatchEvent(new CustomEvent(event.detail.action, {\n            bubbles: false,\n            detail: event.detail,\n        }));\n    }\n\n    /**\n     * Set the initial state.\n     *\n     * @param {object} stateData the initial state data.\n     */\n    setInitialState(stateData) {\n        this.pendingState.resolve();\n        this.stateManager.setInitialState(stateData);\n    }\n\n    /**\n     * Add individual functions to the mutations.\n     *\n     * Note new mutations will be added to the existing ones. To replace the full mutation\n     * object with a new one, use setMutations method.\n     *\n     * @method addMutations\n     * @param {Object} newFunctions an object with new mutation functions.\n     */\n    addMutations(newFunctions) {\n        // Mutations can provide an init method to do some setup in the statemanager.\n        if (newFunctions.init !== undefined) {\n            newFunctions.init(this.stateManager);\n        }\n        // Save all mutations.\n        for (const [mutation, mutationFunction] of Object.entries(newFunctions)) {\n            this.mutations[mutation] = mutationFunction.bind(newFunctions);\n        }\n    }\n\n    /**\n     * Replace the current mutations with a new object.\n     *\n     * This method is designed to override the full mutations class, for example by extending\n     * the original one. To add some individual mutations, use addMutations instead.\n     *\n     * @param {object} manager the new mutations intance\n     */\n    setMutations(manager) {\n        this.mutations = manager;\n        // Mutations can provide an init method to do some setup in the statemanager.\n        if (manager.init !== undefined) {\n            manager.init(this.stateManager);\n        }\n    }\n\n    /**\n     * Return the current state.\n     *\n     * @return {object}\n     */\n    get state() {\n        return this.stateManager.state;\n    }\n\n    /**\n     * Get state data.\n     *\n     * Components access the state frequently. This convenience method is a shortcut to\n     * this.reactive.state.stateManager.get() method.\n     *\n     * @param {String} name the state object name\n     * @param {*} id an optional object id for state maps.\n     * @return {Object|undefined} the state object found\n     */\n    get(name, id) {\n        return this.stateManager.get(name, id);\n    }\n\n    /**\n     * Return the initial state promise.\n     *\n     * Typically, components do not require to use this promise because registerComponent\n     * will trigger their stateReady method automatically. But it could be useful for complex\n     * components that require to combine state, template and string loadings.\n     *\n     * @method getState\n     * @return {Promise}\n     */\n    getInitialStatePromise() {\n        return this.stateManager.getInitialPromise();\n    }\n\n    /**\n     * Register a new component.\n     *\n     * Component can provide some optional functions to the reactive module:\n     * - getWatchers: returns an array of watchers\n     * - stateReady: a method to call when the initial state is loaded\n     *\n     * It can also provide some optional attributes:\n     * - name: the component name (default value: \"Unkown component\") to customize debug messages.\n     *\n     * The method will also use dispatchRegistrationSuccess and dispatchRegistrationFail. Those\n     * are BaseComponent methods to inform parent components of the registration status.\n     * Components should not override those methods.\n     *\n     * @method registerComponent\n     * @param {object} component the new component\n     * @param {string} [component.name] the component name to display in warnings and errors.\n     * @param {Function} [component.dispatchRegistrationSuccess] method to notify registration success\n     * @param {Function} [component.dispatchRegistrationFail] method to notify registration fail\n     * @param {Function} [component.getWatchers] getter of the component watchers\n     * @param {Function} [component.stateReady] method to call when the state is ready\n     * @return {object} the registered component\n     */\n    registerComponent(component) {\n\n        // Component name is an optional attribute to customize debug messages.\n        const componentName = component.name ?? 'Unkown component';\n\n        // Components can provide special methods to communicate registration to parent components.\n        let dispatchSuccess = () => {\n            return;\n        };\n        let dispatchFail = dispatchSuccess;\n        if (component.dispatchRegistrationSuccess !== undefined) {\n            dispatchSuccess = component.dispatchRegistrationSuccess.bind(component);\n        }\n        if (component.dispatchRegistrationFail !== undefined) {\n            dispatchFail = component.dispatchRegistrationFail.bind(component);\n        }\n\n        // Components can be registered only one time.\n        if (this.components.has(component)) {\n            dispatchSuccess();\n            return component;\n        }\n\n        // Components are fully registered only when the state ready promise is resolved.\n        const pendingPromise = new Pending(`core/reactive:registerComponent${pendingCount++}`);\n\n        // Keep track of the event listeners.\n        let listeners = [];\n\n        // Register watchers.\n        let handlers = [];\n        if (component.getWatchers !== undefined) {\n            handlers = component.getWatchers();\n        }\n        handlers.forEach(({watch, handler}) => {\n\n            if (watch === undefined) {\n                dispatchFail();\n                throw new Error(`Missing watch attribute in ${componentName} watcher`);\n            }\n            if (handler === undefined) {\n                dispatchFail();\n                throw new Error(`Missing handler for watcher ${watch} in ${componentName}`);\n            }\n\n            const listener = (event) => {\n                // Prevent any watcher from losing the page focus.\n                const currentFocus = document.activeElement;\n                // Execute watcher.\n                handler.apply(component, [event.detail]);\n                // Restore focus in case it is lost.\n                if (document.activeElement === document.body && document.body.contains(currentFocus)) {\n                    currentFocus.focus();\n                }\n            };\n\n            // Save the listener information in case the component must be unregistered later.\n            listeners.push({target: this.target, watch, listener});\n\n            // The state manager triggers a general \"state changed\" event at a document level. However,\n            // for the internal watchers, each component can listen to specific state changed custom events\n            // in the target element. This way we can use the native event loop without colliding with other\n            // reactive instances.\n            this.target.addEventListener(watch, listener);\n        });\n\n        // Register state ready function. There's the possibility a component is registered after the initial state\n        // is loaded. For those cases we have a state promise to handle this specific state change.\n        if (component.stateReady !== undefined) {\n            this.getInitialStatePromise()\n                .then(state => {\n                    component.stateReady(state);\n                    pendingPromise.resolve();\n                    return true;\n                })\n                .catch(reason => {\n                    pendingPromise.resolve();\n                    log.error(`Initial state in ${componentName} rejected due to: ${reason}`);\n                    log.error(reason);\n                });\n        }\n\n        // Save unregister data.\n        this.watchers.set(component, listeners);\n        this.components.add(component);\n\n        // Dispatch an event to communicate the registration to the debug module.\n        this.target.dispatchEvent(new CustomEvent('registerComponent:success', {\n            bubbles: false,\n            detail: {component},\n        }));\n\n        dispatchSuccess();\n        return component;\n    }\n\n    /**\n     * Unregister a component and its watchers.\n     *\n     * @param {object} component the object instance to unregister\n     * @returns {object} the deleted component\n     */\n    unregisterComponent(component) {\n        if (!this.components.has(component)) {\n            return component;\n        }\n\n        this.components.delete(component);\n\n        // Remove event listeners.\n        const listeners = this.watchers.get(component);\n        if (listeners === undefined) {\n            return component;\n        }\n\n        listeners.forEach(({target, watch, listener}) => {\n            target.removeEventListener(watch, listener);\n        });\n\n        this.watchers.delete(component);\n\n        return component;\n    }\n\n    /**\n     * Dispatch a change in the state.\n     *\n     * This method is the only way for components to alter the state. Watchers will receive a\n     * read only state to prevent illegal changes. If some user action require a state change, the\n     * component should dispatch a mutation to trigger all the necessary logic to alter the state.\n     *\n     * @method dispatch\n     * @param {string} actionName the action name (usually the mutation name)\n     * @param {mixed} params any number of params the mutation needs.\n     */\n    async dispatch(actionName, ...params) {\n        if (typeof actionName !== 'string') {\n            throw new Error(`Dispatch action name must be a string`);\n        }\n        // JS does not have private methods yet. However, we prevent any component from calling\n        // a method starting with \"_\" because the most accepted convention for private methods.\n        if (actionName.charAt(0) === '_') {\n            throw new Error(`Illegal Private ${actionName} mutation method dispatch`);\n        }\n        if (this.mutations[actionName] === undefined) {\n            throw new Error(`Unkown ${actionName} mutation`);\n        }\n\n        const pendingPromise = new Pending(`core/reactive:${actionName}${pendingCount++}`);\n\n        const mutationFunction = this.mutations[actionName];\n        try {\n            await mutationFunction.apply(this.mutations, [this.stateManager, ...params]);\n            pendingPromise.resolve();\n        } catch (error) {\n            // Ensure the state is locked.\n            this.stateManager.setReadOnly(true);\n            pendingPromise.resolve();\n            throw error;\n        }\n    }\n}\n"],"file":"reactive.min.js"}