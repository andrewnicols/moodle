define ("core/local/reactive/reactive",["exports","core/log","core/local/reactive/statemanager","core/pending"],function(_exports,_log,_statemanager,_pending){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.default=void 0;_log=_interopRequireDefault(_log);_statemanager=_interopRequireDefault(_statemanager);_pending=_interopRequireDefault(_pending);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}let pendingCount=0;class _default{constructor(description){var _description$target,_description$mutation;if(description.eventName===void 0||description.eventDispatch===void 0){throw new Error("Reactivity event required")}if(description.name!==void 0){this.name=description.name}this.target=null!==(_description$target=description.target)&&void 0!==_description$target?_description$target:document.createTextNode(null);this.eventName=description.eventName;this.eventDispatch=description.eventDispatch;this.stateManager=new _statemanager.default(this.eventDispatch,this.target);this.watchers=new Map([]);this.components=new Set([]);this.mutations=null!==(_description$mutation=description.mutations)&&void 0!==_description$mutation?_description$mutation:{};this.target.addEventListener(this.eventName,this.callWatchersHandler.bind(this));this.pendingState=new _pending.default("core/reactive:registerInstance".concat(pendingCount++));if(description.state!==void 0){this.setInitialState(description.state)}if(M.reactive!==void 0){M.reactive.registerNewInstance(this)}}callWatchersHandler(event){this.target.dispatchEvent(new CustomEvent(event.detail.action,{bubbles:!1,detail:event.detail}))}setInitialState(stateData){this.pendingState.resolve();this.stateManager.setInitialState(stateData)}addMutations(newFunctions){if(newFunctions.init!==void 0){newFunctions.init(this.stateManager)}for(const[mutation,mutationFunction]of Object.entries(newFunctions)){this.mutations[mutation]=mutationFunction.bind(newFunctions)}}setMutations(manager){this.mutations=manager;if(manager.init!==void 0){manager.init(this.stateManager)}}get state(){return this.stateManager.state}get(name,id){return this.stateManager.get(name,id)}getInitialStatePromise(){return this.stateManager.getInitialPromise()}registerComponent(component){var _component$name;const componentName=null!==(_component$name=component.name)&&void 0!==_component$name?_component$name:"Unkown component";let dispatchSuccess=()=>{},dispatchFail=dispatchSuccess;if(component.dispatchRegistrationSuccess!==void 0){dispatchSuccess=component.dispatchRegistrationSuccess.bind(component)}if(component.dispatchRegistrationFail!==void 0){dispatchFail=component.dispatchRegistrationFail.bind(component)}if(this.components.has(component)){dispatchSuccess();return component}const pendingPromise=new _pending.default("core/reactive:registerComponent".concat(pendingCount++));let listeners=[],handlers=[];if(component.getWatchers!==void 0){handlers=component.getWatchers()}handlers.forEach(_ref=>{let{watch,handler}=_ref;if(watch===void 0){dispatchFail();throw new Error("Missing watch attribute in ".concat(componentName," watcher"))}if(handler===void 0){dispatchFail();throw new Error("Missing handler for watcher ".concat(watch," in ").concat(componentName))}const listener=event=>{const currentFocus=document.activeElement;handler.apply(component,[event.detail]);if(document.activeElement===document.body&&document.body.contains(currentFocus)){currentFocus.focus()}};listeners.push({target:this.target,watch,listener});this.target.addEventListener(watch,listener)});if(component.stateReady!==void 0){this.getInitialStatePromise().then(state=>{component.stateReady(state);pendingPromise.resolve();return!0}).catch(reason=>{pendingPromise.resolve();_log.default.error("Initial state in ".concat(componentName," rejected due to: ").concat(reason));_log.default.error(reason)})}this.watchers.set(component,listeners);this.components.add(component);this.target.dispatchEvent(new CustomEvent("registerComponent:success",{bubbles:!1,detail:{component}}));dispatchSuccess();return component}unregisterComponent(component){if(!this.components.has(component)){return component}this.components.delete(component);const listeners=this.watchers.get(component);if(listeners===void 0){return component}listeners.forEach(_ref2=>{let{target,watch,listener}=_ref2;target.removeEventListener(watch,listener)});this.watchers.delete(component);return component}async dispatch(actionName){if("string"!=typeof actionName){throw new Error("Dispatch action name must be a string")}if("_"===actionName.charAt(0)){throw new Error("Illegal Private ".concat(actionName," mutation method dispatch"))}if(this.mutations[actionName]===void 0){throw new Error("Unkown ".concat(actionName," mutation"))}const pendingPromise=new _pending.default("core/reactive:".concat(actionName).concat(pendingCount++)),mutationFunction=this.mutations[actionName];try{for(var _len=arguments.length,params=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++){params[_key-1]=arguments[_key]}await mutationFunction.apply(this.mutations,[this.stateManager,...params]);pendingPromise.resolve()}catch(error){this.stateManager.setReadOnly(!0);pendingPromise.resolve();throw error}}}_exports.default=_default;return _exports.default});
//# sourceMappingURL=reactive.min.js.map
