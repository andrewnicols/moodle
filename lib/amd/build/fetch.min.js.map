{"version":3,"file":"fetch.min.js","sources":["../src/fetch.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A wrapper around the browser Fetch API to be used with the Moodle Web Services.\n *\n * @module     core/fetch\n * @copyright  2022 Andrew Lyons < andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      4.2\n */\n\nimport config from 'core/config';\nimport Log from 'core/log';\nimport MoodleURL from 'core/url';\nimport Pending from 'core/pending';\n\nconst maxUrlLength = 2000;\n\n// TODO See if we can avoid using the beforeunload event as it has a detremental impact.\nlet unloading = false;\nwindow.addEventListener('beforeunload', () => {\n    unloading = true;\n});\n\nconst getServiceUrl = (\n    loginRequired,\n    cacheKey,\n) => {\n    const serviceUrl = new URL(\n        loginRequired ? 'service.php' : 'service-nologin.php',\n        `${config.wwwroot}/lib/ajax/`,\n    );\n\n    if (loginRequired) {\n        // Add the sesskey to the URL.\n        serviceUrl.searchParams.set('sesskey', config.sesskey);\n    } else if (cacheKey) {\n        // A cache key can only be added to public requests.\n        serviceUrl.searchParams.set('cachekey', cacheKey);\n    }\n\n    return serviceUrl;\n};\n\nconst getMethod = (loginRequired, cacheKey) => {\n    if (!loginRequired && cacheKey) {\n        return 'GET';\n    }\n\n    return 'POST';\n};\n\nconst getCacheKey = (cacheKey = null) => {\n    if (cacheKey) {\n        const key = parseInt(cacheKey);\n        if (key <= 0 || !key) {\n            return null;\n        }\n\n        return key;\n    }\n\n    return null;\n};\n\nexport const fetchOne = (methodname, args, loginRequired = true, options) => fetchMany(\n    [{methodname, args}],\n    loginRequired,\n    options\n)[0];\n\nexport const fetchMany = (queries, loginRequired = true, {\n    updateSession = true,\n    timeout = 0,\n    cacheKey = null,\n} = {}) => {\n    const requestData = [];\n    const resolvers = new Map();\n\n    const promises = queries.map((request, index) => new Promise((resolve, reject) => {\n        const {methodname, args} = request;\n\n        // The request data that we pass to the service includes index, methodname, args.\n        requestData.push({\n            index,\n            methodname,\n            args,\n        });\n\n        // Store the Promise resolvers for this request against its index.\n        resolvers.set(index, {\n            resolve,\n            reject,\n        });\n    }));\n\n    // Get the base service URL.\n    const serviceUrl = getServiceUrl(loginRequired, getCacheKey(cacheKey));\n\n    if (!updateSession) {\n        serviceUrl.searchParams.set('nosessionupdate', true);\n    }\n\n    // Set a request summary in the URL to assist in caching.\n    serviceUrl.searchParams.set('info', getRequestSummary(queries));\n\n    // Note: Do not await this call, it will be resolved later.\n    fetchRequests(serviceUrl, requestData, resolvers, loginRequired, updateSession, timeout, cacheKey);\n\n    return promises;\n};\n\nconst getAbortController = (timeout) => {\n    if (timeout <= 0) {\n        return {\n            abortTimer: null,\n            abortController: null,\n        };\n    }\n\n    const abortController = new AbortController();\n    const abortTimer = setTimeout(() => {\n        abortController.abort();\n    }, timeout * 1000);\n\n    return {\n        abortTimer,\n        abortController,\n    };\n};\n\nconst getRequestSummary = (requests) => {\n    if (requests.length <= 5) {\n        return requests.map((request) => request.methodname).sort().join();\n    }\n\n    return `${requests.length}-method-calls`;\n};\n\nconst fetchRequests = async(serviceUrl, requests, resolvers, loginRequired, updateSession, timeout, cacheKey) => {\n    const options = {\n        method: getMethod(loginRequired, cacheKey),\n        headers: [\n            ['Content-Type', 'application/json'],\n        ],\n    };\n\n    if (options.method === 'GET') {\n        serviceUrl.searchParams.set('args', JSON.stringify(requests));\n        if (serviceUrl.toString().length > maxUrlLength) {\n            options.method = 'POST';\n            serviceUrl.searchParams.delete('args');\n        }\n    }\n\n    if (options.method === 'POST') {\n        // It isn't possible to cache POST requests.\n        serviceUrl.searchParams.delete('cachekey');\n\n        // TODO Look at whether we can move the sesskey into the body too.\n\n        // This is a POST request so add the data to the body.\n        options.body = JSON.stringify(requests);\n    }\n\n    // Register the abort controller immediately before the request is made.\n    const {abortController, abortTimer} = getAbortController(timeout);\n    if (abortController) {\n        options.signal = abortController;\n    }\n\n    const pendingPromise = new Pending('core/fetch:fetchRequests');\n    try {\n        const response = await fetch(serviceUrl, options);\n\n        // Clear the abort timer before handling responses otherwise it will apply to responses too.\n        clearTimeout(abortTimer);\n\n        // Process the responses and resolve the promises.\n        handleResponses(updateSession, response, resolvers);\n    } catch (error) {\n        // Clear the abort timer before handling responses otherwise it will apply to responses too.\n        clearTimeout(abortTimer);\n\n        // Process the responses and reject the promises.\n        handleFailure(resolvers, error);\n    } finally {\n        pendingPromise.resolve();\n    }\n};\n\nconst handleFailure = (resolvers, error) => {\n    if (unloading) {\n        Log.error(`Page unloaded - exception ignored: ${error}`);\n        return;\n    }\n\n    // Reject each promise.\n    try {\n        resolvers.forEach(({reject}) => reject(error));\n    } catch {\n        // Pass.\n    }\n};\n\nconst checkLoginRequired = (exception, updateSession) => {\n    if (exception.errorcode === 'servicerequireslogin' && updateSession) {\n        // The user is not logged in, redirect to the login page.\n        window.location = MoodleURL.relativeUrl(\"/login/index.php\");\n        return;\n    }\n};\n\nconst handleResponses = async(updateSession, response, resolvers) => {\n    const responseData = await response.json();\n    if (responseData.error) {\n        // Throwing an error here will cause all of the promises to be rejected by the calling code.\n        throw new Error(responseData.error);\n    }\n\n    // Resolve each of the responses.\n    responseData.some((response, index) => {\n        if (response.error) {\n            // If any response errored then reject this and all remaining promises.\n            checkLoginRequired(response.exception, updateSession);\n            resolvers.forEach(({reject}) => reject(response.exception));\n            return true;\n        }\n\n        // Resolve the promise with the response data and continue.\n        resolvers.get(index).resolve(response.data);\n        // Remove the resolver so that any failures in subsequent keys do not cause it to reject.\n        resolvers.delete(index);\n        return false;\n    });\n\n    return responseData;\n};\n"],"names":["unloading","window","addEventListener","getServiceUrl","loginRequired","cacheKey","serviceUrl","URL","config","wwwroot","searchParams","set","sesskey","getMethod","getCacheKey","key","parseInt","methodname","args","options","fetchMany","queries","updateSession","timeout","requestData","resolvers","Map","promises","map","request","index","Promise","resolve","reject","push","getRequestSummary","fetchRequests","requests","length","sort","join","async","method","headers","JSON","stringify","toString","delete","body","abortController","abortTimer","AbortController","setTimeout","abort","getAbortController","signal","pendingPromise","Pending","response","fetch","clearTimeout","handleResponses","error","handleFailure","forEach","_ref","responseData","json","Error","some","exception","errorcode","location","MoodleURL","relativeUrl","checkLoginRequired","_ref2","get","data"],"mappings":"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"}