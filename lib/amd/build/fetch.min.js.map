{"version":3,"file":"fetch.min.js","sources":["../src/fetch.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The core/fetch module allows you to make web service requests to the Moodle API.\n *\n * @module     core/fetch\n * @copyright  Andrew Lyons <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Cfg from 'core/config';\nimport PendingPromise from './pending';\n\n/**\n * A wrapper around the Request, including a Promise that is resolved when the request is complete.\n */\nclass RequestWrapper {\n    /** @var {Request} */\n    #request = null;\n\n    /** @var {Promise} */\n    #promise = null;\n\n    /** @var {Function} */\n    #resolve = null;\n\n    /** @var {Function} */\n    #reject = null;\n\n    /**\n     * Create a new RequestWrapper.\n     *\n     * @param {Request} request The request object that is wrapped\n     */\n    constructor(request) {\n        this.#request = request;\n        this.#promise = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n\n    /**\n     * Get the wrapped Request.\n     *\n     * @returns {Request}\n     * @private\n     */\n    get request() {\n        return this.#request;\n    }\n\n    /**\n     * Get the Promise link to this request.\n     *\n     * @return {Promise}\n     * @private\n     */\n    get promise() {\n        return this.#promise;\n    }\n\n    /**\n     * Reject the Promise.\n     */\n    get reject() {\n        return this.#reject;\n    }\n\n    /**\n     * Handle the response from the request.\n     *\n     * @param {Response} response\n     * @private\n     */\n    handleResponse(response) {\n        if (response.ok) {\n            this.#resolve(response);\n        } else {\n            this.#reject(response.statusText);\n        }\n    }\n}\n\n/**\n * The core/fetch module allows you to make web service requests to the Moodle API.\n *\n * Most methods are available both statically and via an instance method, for example\n * `Fetch.performGet()` and `(new Fetch()).performGet()`.\n *\n * The static perform methods perform immediate individual requests, whilst instance\n * methods are useful for batching requests.\n *\n * By default the Fetch instance will not automatically execute the batch, but it can be configured to do so\n * by passing a value for the `autoBatchTimeout` parameter.\n *\n * The batcher can be executed manually by calling the {@linkcode module:core/fetch#execute|execute} method.\n *\n * Note: In cases where the batcher is executed with a single request the batch endpoint is _not_ used.\n *\n * A helper method, {@linkcode module:core/fetch#getBatcher|getBatcher}, exists to fetch a singleton instance\n * of the class. This singleton is configured to automatically execute batch requests.\n *\n * @example <caption>Perform a single GET request</caption>\n * import Fetch from 'core/fetch';\n *\n * // Execute three individual requests.\n * const actions = await Promise.all([\n *     Fetch.performGet('mod_example', 'animals', { params: { type: 'mammal' }),\n *     Fetch.performGet('mod_example', 'animals', { params: { type: 'reptile' }),\n *     Fetch.performDelete('mod_example', `animals/${pig.id}`}),\n * ]);\n *\n * // Print the information about mammals.\n * window.console.log(actions[0]);\n *\n * @example <caption>Perform a series of requests, automatically batching them</caption>\n * import Fetch from 'core/fetch';\n *\n * // Execute a single request containing three sub requests.\n * const batcher = Fetch.getBatcher();\n * const actions = await Promise.all([\n *     batcher.performGet('mod_example', 'animals', { params: { type: 'mammal' }),\n *     batcher.performGet('mod_example', 'animals', { params: { type: 'reptile' }),\n *     batcher.performDelete('mod_example', `animals/${pig.id}`}),\n * ]);\n *\n * // Print the information about mammals.\n * window.console.log(actions[0]);\n *\n * @example <caption>Perform a series of GET request, manually batching them</caption>\n * import Fetch from 'core/fetch';\n *\n * const batcher = new Fetch();\n * const mammals = batcher.performGet('mod_example', 'animals', { params: { type: 'mammal' });\n * const actions = Promise.all([\n *     batcher.performGet('mod_example', 'animals', { params: { type: 'mammal' }),\n *     batcher.performGet('mod_example', 'animals', { params: { type: 'reptile' }),\n *     batcher.performDelete('mod_example', `animals/${pig.id}`}),\n * ]);\n *\n * batcher.execute();\n *\n * await actions;\n *\n * // Print the information about mammals.\n * window.console.log(actions[0]);\n */\nexport default class Fetch {\n    /** @var {Map} #requestMap A Map of requests to execute */\n    #requestMap = new Map();\n\n    /** @var {null|self} #batcher The active instance of the batcher */\n    static #batcher = null;\n\n    /** @var {null|number} #delayTimer The timeout for the batch processor */\n    #delayTimer = null;\n\n    /** @var {Boolean} */\n    #batchRequests = false;\n\n    /**\n     * The delay timer to use for the autobatcher.\n     * A `null` value disables automatic execution\n     * @var {boolean|Number} #autoBatchTimeout\n     */\n    #autoBatchTimeout = null;\n\n    /**\n     * Create a new instance of the Fetch Class.\n     *\n     * When methods are called on an Instance, they are queued and executed as a batch.\n     *\n     * By default the Fetch instance will not automatically execute the batch, but it can be configured to do so\n     * by passing a value for the `autoBatchTimeout` parameter.\n     *\n     * The batcher can be executed manually by calling the {@link module:core/fetch:execute} method.\n     * The batcher can be executed manually by calling the {@link class:core/fetch:execute} method.\n     *\n     * In cases where the batcher is executed with a single request the batch endpoint is _not_ used.\n     *\n     * @param {Number|null} [autoBatchTimeout=null] The amount of time to use when applying the automatic batch timer.\n     *                                       If null, the autobatcher is disabled.\n     */\n    constructor(autoBatchTimeout = null) {\n        this.#autoBatchTimeout = autoBatchTimeout;\n\n        this.#batchRequests = Cfg.batchFetchRequests;\n    }\n\n    /**\n     * Get the singleton instance of batch processor.\n     *\n     * Note: The singleton instance is configured to automatically execute the batch 50ms after the final request is added.\n     *\n     * @returns {Fetch}\n     */\n    static getBatcher() {\n        if (!this.#batcher) {\n            this.#batcher = new this(50);\n        }\n\n        return this.#batcher;\n    }\n\n    /**\n     * Make a single request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @param {string|Object|FormData} [params.body = null] The HTTP method to use\n     * @param {string} [params.method = \"GET\"] The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static async request(\n        component,\n        action,\n        {\n            params = {},\n            body = null,\n            method = 'GET',\n        } = {},\n    ) {\n        const pending = new PendingPromise(`Requesting ${component}/${action} with ${method}`);\n        const requestWrapper = Fetch.#getRequest(\n            Fetch.#normaliseComponent(component),\n            action,\n            { params, method, body },\n        );\n        const result = await fetch(requestWrapper.request);\n\n        pending.resolve();\n\n        requestWrapper.handleResponse(result);\n\n        return requestWrapper.promise;\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performGet(\n        component,\n        action,\n        {\n            params = {},\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            { params, method: 'GET' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performHead(\n        component,\n        action,\n        {\n            params = {},\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            { params, method: 'HEAD' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performPost(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            { body, method: 'POST' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performPut(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            { body, method: 'PUT' },\n        );\n    }\n\n    /**\n     * Make a PATCH request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performPatch(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            { body, method: 'PATCH' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @param {string|Object|FormData} [params.body = null] The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    static performDelete(\n        component,\n        action,\n        {\n            params = {},\n            body = null,\n        } = {},\n    ) {\n        return this.request(\n            component,\n            action,\n            {\n                body,\n                params,\n                method: 'DELETE',\n            },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performGet(\n        component,\n        action,\n        {\n            params = {},\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            { params, method: 'GET' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performHead(\n        component,\n        action,\n        {\n            params = {},\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            { params, method: 'HEAD' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performPost(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            { body, method: 'POST' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performPut(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            { body, method: 'PUT' },\n        );\n    }\n\n    /**\n     * Make a PATCH request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {string|Object|FormData} params.body The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performPatch(\n        component,\n        action,\n        {\n            body,\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            { body, method: 'PATCH' },\n        );\n    }\n\n    /**\n     * Make a request to the Moodle API.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} action The component action to perform\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @param {string|Object|FormData} [params.body = null] The HTTP method to use\n     * @returns {Promise<Response>} A promise that resolves to the Response object for the request\n     */\n    performDelete(\n        component,\n        action,\n        {\n            params = {},\n            body = null,\n        } = {},\n    ) {\n        return this.#addRequest(\n            component,\n            action,\n            {\n                body,\n                params,\n                method: 'DELETE',\n            },\n        );\n    }\n\n    /**\n     * Execute the batch request.\n     *\n     * @returns {Promise<void>}\n     */\n    async execute() {\n        const requestMap = this.#requestMap;\n        this.#requestMap = new Map();\n\n        if (requestMap.size === 0) {\n            return Promise.resolve();\n        }\n\n        if (requestMap.size === 1) {\n            const requestWrapper = requestMap.values().next().value;\n            const result = await fetch(requestWrapper.request);\n\n            requestWrapper.handleResponse(result);\n\n            return;\n        }\n\n        const response = await fetch(await this.#getRequests(requestMap));\n        if (!response.ok) {\n            requestMap.forEach((requestWrapper) => requestWrapper.reject(response.statusText));\n            return;\n        }\n\n        const responses = await this.#processBatchResponse(response);\n\n        // TODO: Use the request-id and map it to the request/response.\n        let index = 0;\n        requestMap.forEach((requestWrapper) => {\n            if (responses[index]) {\n                const result = this.#getResponseFromText(responses[index]);\n                requestWrapper.handleResponse(result);\n            } else {\n                requestWrapper.reject(\"Request failed\");\n            }\n            index++;\n        });\n    }\n\n    /**\n     * Normalise the component name to remove the core_ prefix.\n     *\n     * @param {string} component\n     * @returns {string}\n     */\n    static #normaliseComponent(component) {\n        return component.replace(/^core_/, '');\n    }\n\n    /**\n     * Add a request to the batch queue.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} endpoint The endpoint within the componet to call\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @param {string|Object|FormData} [params.body = null] The HTTP method to use\n     * @param {string} [params.method = \"GET\"] The HTTP method to use\n     * @param {string} [params.id = null] The ID of the request (Reserved for future use)\n     * @returns {Promise}\n     */\n    #addRequest(\n        component,\n        endpoint,\n        {\n            params = {},\n            body = null,\n            method = 'GET',\n            id = null,\n        } = {},\n    ) {\n        if (this.#requestMap.length > 20) {\n            this.execute();\n        }\n\n        if (id) {\n            if (this.#requestMap.has(id)) {\n                throw new Error(`Request with ID ${id} already exists.`);\n            }\n        } else {\n            do {\n                id = this.#getGuid();\n            } while (this.#requestMap.has(id));\n        }\n\n        const request = Fetch.#getRequest(\n            Fetch.#normaliseComponent(component),\n            endpoint,\n            { params, method, body },\n        );\n\n        this.#requestMap.set(id, request);\n\n        if (!this.#batchRequests) {\n            this.execute();\n        } else if (this.#autoBatchTimeout) {\n            this.#queueExecution();\n        }\n\n        return request.promise;\n    }\n\n    /**\n     * Queue the execution of the batch request.\n     */\n    #queueExecution() {\n        if (this.#delayTimer) {\n            clearTimeout(this.#delayTimer);\n        }\n        this.#delayTimer = setTimeout(() => this.execute(), this.#autoBatchTimeout);\n    }\n\n    /**\n     * Get the Request for a given API request.\n     *\n     * @param {string} component The frankenstyle component name\n     * @param {string} endpoint The endpoint within the componet to call\n     * @param {object} params\n     * @param {object} [params.params = {}] The parameters to pass to the API\n     * @param {string|Object|FormData} [params.body = null] The HTTP method to use\n     * @param {string} [params.method = \"GET\"] The HTTP method to use\n     * @returns {RequestWrapper}\n     */\n    static #getRequest(\n        component,\n        endpoint,\n        {\n            params = {},\n            body = null,\n            method = 'GET',\n        }\n    ) {\n        const url = new URL(`${Cfg.apibase}/rest/v2/${component}/${endpoint}`);\n        const options = {\n            method,\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n            },\n        };\n\n        Object.entries(params).forEach(([key, value]) => {\n            url.searchParams.append(key, value);\n        });\n\n        if (body) {\n            if (body instanceof FormData) {\n                options.body = body;\n            } else if (body instanceof Object) {\n                options.body = JSON.stringify(body);\n            } else {\n                options.body = body;\n            }\n        }\n\n        return new RequestWrapper(new Request(url, options));\n    }\n\n    /**\n     * Get the Compiled batch Request.\n     *\n     * @param {Map<Object>} requestMap\n     * @returns {Promise<Request>}\n     */\n    async #getRequests(requestMap) {\n        const boundary = this.#getGuid();\n        const getBoundaryMarker = () => `--${boundary}\\n`;\n\n        const getRequestHeader = () => ([\n            getBoundaryMarker(),\n            `Content-Type: application/html\\n\\n`,\n        ]);\n\n        const [...requestBodies] = await Promise.all(requestMap.entries().map(async ([id, { request }]) => {\n            const thisBody = [];\n            thisBody.push(...getRequestHeader());\n            thisBody.push(`${request.method} ${request.url}\\n`);\n            thisBody.push(`Content-Type: ${request.headers.get('Content-Type')}\\n`);\n            thisBody.push(`Content-ID: ${id}\\n`);\n\n            if (request.body) {\n                thisBody.push(`\\n`);\n                thisBody.push(await request.text());\n            }\n\n            thisBody.push(`\\n`);\n            return thisBody;\n        }));\n\n        const body = [\n            ...requestBodies.map((requestBody) => requestBody.join(\"\")),\n            getBoundaryMarker(),\n        ];\n\n        return new Request(\n            `${M.cfg.apibase}/$batch`,\n            {\n                body: body.join(\"\"),\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": `multipart/mixed;boundary=${boundary}`,\n                },\n            },\n        );\n    }\n\n    #getResponseFromText(text) {\n        // Parts are:\n        // - Boundary\n        // - Headers\n        // - Any body (optional)\n        // - Boundary\n        const parts = text.split(`\\n\\n`).map((part) => part.trim());\n\n        // Remove the boundaries\n        parts.shift();\n        parts.pop();\n\n        // Add an extra part on to simplify header/body extractiona\n        parts.push(null);\n\n        const [headerText, body] = parts;\n        const headers = headerText.split(`\\n`);\n\n        // Extract the status from the rest of the headers.\n        const statusLine = headers.shift();\n        const [, status, statusText] = statusLine.split(` `);\n\n        const headerList = headers.map((header) => header.split(\":\", 2).map((value) => value.trim()));\n\n        return new Response(body, {\n            status,\n            statusText,\n            headers: new Headers(headerList),\n        });\n    }\n\n    async #processBatchResponse(response) {\n        // Handle the response type.\n        const contentType = response.headers.get('Content-Type');\n        if (contentType.startsWith('multipart/mixed')) {\n            const [, boundaryPart] = contentType.split(';').map((part) => part.trim());\n            const boundary = boundaryPart.replace('boundary=', '').trim();\n\n            // Handle HTML response.\n            const responseBody = await response.text();\n\n            return responseBody.split(`--${boundary}`).filter((value) => !!value.length);\n        } else if (contentType === 'application/json') {\n            // Handle JSON response\n            return await response.json();\n        }\n\n        throw new Error(\n            `Unknown response type '${contentType}'`,\n        );\n    }\n\n    #getGuid() {\n        let d = new Date().getTime();\n        const guid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n            const r = (d + Math.random() * 16) % 16 | 0; // eslint-disable-line no-bitwise\n            d = Math.floor(d / 16);\n            return (c === \"x\" ? r : (r & 0x3 | 0x8)).toString(16); // eslint-disable-line no-bitwise\n        });\n        return guid;\n    }\n}\n"],"names":["RequestWrapper","constructor","request","Promise","resolve","reject","this","promise","handleResponse","response","ok","statusText","Fetch","autoBatchTimeout","Map","Cfg","batchFetchRequests","component","action","params","body","method","pending","PendingPromise","requestWrapper","result","fetch","performGet","performHead","performPost","performPut","performPatch","performDelete","requestMap","size","values","next","value","forEach","responses","index","replace","endpoint","id","_classPrivateFieldGet","length","execute","has","Error","set","clearTimeout","setTimeout","url","URL","apibase","options","headers","Object","entries","_ref2","key","searchParams","append","FormData","JSON","stringify","Request","boundary","getBoundaryMarker","requestBodies","all","map","async","thisBody","push","get","text","requestBody","join","M","cfg","parts","split","part","trim","shift","pop","headerText","statusLine","status","headerList","header","Response","Headers","contentType","startsWith","boundaryPart","filter","json","d","Date","getTime","c","r","Math","random","floor","toString"],"mappings":"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"}