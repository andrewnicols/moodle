{"version":3,"file":"fetch.min.js","sources":["../src/fetch.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A wrapper around the browser Fetch API to be used with the Moodle Web Services.\n *\n * @module     core/fetch\n * @copyright  2022 Andrew Lyons < andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      4.2\n */\n\nimport config from 'core/config';\nimport Log from 'core/log';\nimport MoodleURL from 'core/url';\nimport Pending from 'core/pending';\n\nconst maxUrlLength = 2000;\n\n// TODO See if we can avoid using the beforeunload event as it has a detremental impact.\nlet unloading = false;\nwindow.addEventListener('beforeunload', () => {\n    unloading = true;\n});\n\nconst getServiceUrl = (\n    loginRequired,\n    cacheKey,\n) => {\n    const serviceUrl = new URL(\n        loginRequired ? 'service.php' : 'service-nologin.php',\n        `${config.wwwroot}/lib/ajax/`,\n    );\n\n    if (loginRequired) {\n        // Add the sesskey to the URL.\n        serviceUrl.searchParams.set('sesskey', config.sesskey);\n    } else if (cacheKey) {\n        // A cache key can only be added to public requests.\n        serviceUrl.searchParams.set('cachekey', cacheKey);\n    }\n\n    return serviceUrl;\n};\n\nconst getMethod = (loginRequired, cacheKey) => {\n    if (!loginRequired && cacheKey) {\n        return 'GET';\n    }\n\n    return 'POST';\n};\n\nconst getCacheKey = (cacheKey = null) => {\n    if (cacheKey) {\n        const key = parseInt(cacheKey);\n        if (key <= 0 || !key) {\n            return null;\n        }\n\n        return key;\n    }\n\n    return null;\n};\n\nexport const fetchOne = (methodname, args, loginRequired = true, options) => fetchMany(\n    [{methodname, args}],\n    loginRequired,\n    options\n)[0];\n\nexport const fetchMany = (queries, loginRequired = true, {\n    updateSession = true,\n    timeout = 0,\n    cacheKey = null,\n} = {}) => {\n    const requestData = [];\n    const resolvers = new Map();\n\n    const promises = queries.map((request, index) => new Promise((resolve, reject) => {\n        const {methodname, args} = request;\n\n        // The request data that we pass to the service includes index, methodname, args.\n        requestData.push({\n            index,\n            methodname,\n            args,\n        });\n\n        // Store the Promise resolvers for this request against its index.\n        resolvers.set(index, {\n            resolve,\n            reject,\n        });\n    }));\n\n    // Get the base service URL.\n    const serviceUrl = getServiceUrl(loginRequired, getCacheKey(cacheKey));\n\n    if (!updateSession) {\n        serviceUrl.searchParams.set('nosessionupdate', true);\n    }\n\n    // Set a request summary in the URL to assist in caching.\n    serviceUrl.searchParams.set('info', getRequestSummary(queries));\n\n    // Note: Do not await this call, it will be resolved later.\n    fetchRequests(serviceUrl, requestData, resolvers, loginRequired, updateSession, timeout, cacheKey);\n\n    return promises;\n};\n\nconst getAbortController = (timeout) => {\n    if (timeout <= 0) {\n        return {\n            abortTimer: null,\n            abortController: null,\n        };\n    }\n\n    const abortController = new AbortController();\n    const abortTimer = setTimeout(() => {\n        abortController.abort();\n    }, timeout * 1000);\n\n    return {\n        abortTimer,\n        abortController,\n    };\n};\n\nconst getRequestSummary = (requests) => {\n    if (requests.length <= 5) {\n        return requests.map((request) => request.methodname).sort().join();\n    }\n\n    return `${requests.length}-method-calls`;\n};\n\nconst fetchRequests = async(serviceUrl, requests, resolvers, loginRequired, updateSession, timeout, cacheKey) => {\n    const options = {\n        method: getMethod(loginRequired, cacheKey),\n        headers: [\n            ['Content-Type', 'application/json'],\n        ],\n    };\n\n    if (options.method === 'GET') {\n        serviceUrl.searchParams.set('args', JSON.stringify(requests));\n        if (serviceUrl.toString().length > maxUrlLength) {\n            options.method = 'POST';\n            serviceUrl.searchParams.delete('args');\n        }\n    }\n\n    if (options.method === 'POST') {\n        // It isn't possible to cache POST requests.\n        serviceUrl.searchParams.delete('cachekey');\n\n        // TODO Look at whether we can move the sesskey into the body too.\n\n        // This is a POST request so add the data to the body.\n        options.body = JSON.stringify(requests);\n    }\n\n    // Register the abort controller immediately before the request is made.\n    const {abortController, abortTimer} = getAbortController(timeout);\n    if (abortController) {\n        options.signal = abortController;\n    }\n\n    const pendingPromise = new Pending('core/fetch:fetchRequests');\n    try {\n        const response = await fetch(serviceUrl, options);\n\n        // Clear the abort timer before handling responses otherwise it will apply to responses too.\n        clearTimeout(abortTimer);\n\n        // Process the responses and resolve the promises.\n        handleResponses(updateSession, response, resolvers);\n    } catch (error) {\n        // Clear the abort timer before handling responses otherwise it will apply to responses too.\n        clearTimeout(abortTimer);\n\n        // Process the responses and reject the promises.\n        handleFailure(resolvers, error);\n    } finally {\n        pendingPromise.resolve();\n    }\n};\n\nconst handleFailure = (resolvers, error) => {\n    if (unloading) {\n        Log.error(`Page unloaded - exception ignored: ${error}`);\n        return;\n    }\n\n    // Reject each promise.\n    try {\n        resolvers.forEach(({reject}) => reject(error));\n    } catch {\n        // Pass.\n    }\n};\n\nconst checkLoginRequired = (exception, updateSession) => {\n    if (exception.errorcode === 'servicerequireslogin' && updateSession) {\n        // The user is not logged in, redirect to the login page.\n        window.location = MoodleURL.relativeUrl(\"/login/index.php\");\n        return;\n    }\n};\n\nconst handleResponses = async(updateSession, response, resolvers) => {\n    const responseData = await response.json();\n    if (responseData.error) {\n        // Throwing an error here will cause all of the promises to be rejected by the calling code.\n        throw new Error(responseData.error);\n    }\n\n    // Resolve each of the responses.\n    responseData.some((response, index) => {\n        if (response.error) {\n            // If any response errored then reject this and all remaining promises.\n            checkLoginRequired(response.exception, updateSession);\n            resolvers.forEach(({reject}) => reject(response.exception));\n            return true;\n        }\n\n        // Resolve the promise with the response data and continue.\n        resolvers.get(index).resolve(response.data);\n        // Remove the resolver so that any failures in subsequent keys do not cause it to reject.\n        resolvers.delete(index);\n        return false;\n    });\n\n    return responseData;\n};\n"],"names":["_interopRequireDefault","obj","__esModule","default","_config","_log","_url","_pending","unloading","window","addEventListener","getServiceUrl","loginRequired","cacheKey","serviceUrl","URL","concat","config","wwwroot","searchParams","set","sesskey","getMethod","getCacheKey","arguments","length","undefined","key","parseInt","_exports","fetchOne","methodname","args","fetchMany","queries","updateSession","timeout","requestData","resolvers","Map","promises","map","request","index","Promise","resolve","reject","push","getRequestSummary","fetchRequests","requests","sort","join","async","options","method","headers","JSON","stringify","toString","delete","body","abortController","abortTimer","AbortController","setTimeout","abort","getAbortController","signal","pendingPromise","Pending","response","fetch","clearTimeout","handleResponses","error","handleFailure","Log","forEach","_ref","responseData","json","Error","some","checkLoginRequired","exception","errorcode","location","MoodleURL","relativeUrl","_ref2","get","data"],"mappings":"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"}