{"version":3,"file":"fragment.min.js","sources":["../src/fragment.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * A way to call HTML fragments to be inserted as required via JavaScript.\n *\n * @module     core/fragment\n * @copyright  2016 Adrian Greeve <adrian@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      3.1\n */\nimport $ from 'jquery';\nimport {fetchOne} from 'core/fetch';\nimport {getList} from 'core/normalise';\n\nconst formatParams = (params) => {\n    if (params === null) {\n        return [];\n    }\n\n    if (typeof params === 'object') {\n        return Array.from(Object.entries(params));\n    }\n\n    return [];\n};\n\n/**\n * Loads an HTML fragment through a callback.\n *\n * @param {string} component Component where callback is located.\n * @param {string} callback Callback function name.\n * @param {integer} contextid Context ID of the fragment.\n * @param {object} params Parameters for the callback.\n * @return {Promise} JQuery promise object resolved when the fragment has been loaded.\n */\nconst innerLoadFragment = (component, callback, contextid, params) => {\n    // Change params into required webservice format.\n    const args = formatParams(params).map(([name, value]) => ({\n        name,\n        value,\n    }));\n\n    return fetchOne('core_get_fragment', {\n        component,\n        callback,\n        contextid,\n        args,\n    });\n};\n\n/**\n * Converts the JS that was received from collecting JS requirements on the $PAGE so it can be added to the existing page\n *\n * @param {string} js\n * @returns {string}\n */\nconst processCollectedJavascript = (js) => {\n    const nodes = getList($(js));\n    return nodes.map((scriptNode) => {\n        const tagName = scriptNode.tagName?.toLowerCase();\n        if (!tagName || tagName !== 'script') {\n            return null;\n        }\n\n        if (!scriptNode.hasAttribute('src')) {\n            return scriptNode.text;\n        }\n\n        const anyScriptMatches = () => {\n            return Array.from([...document.querySelectorAll('script')]).some((script) => {\n                return script.getAttribute('src') === scriptNode.getAttribute('src');\n            });\n        };\n\n        if (anyScriptMatches()) {\n            return null;\n        }\n        return `{\n            node = document.createElement('script');\n            node.type = 'text/javascript';\n            node.src = decodeURI(\"${encodeURI(scriptNode.getAttribute('src'))}\");\n            document.getElementsByTagName('head')[0].appendChild(node);\n        }`;\n    })\n    .filter((script) => !!script)\n    .join(' ');\n};\n\n/**\n * Appends HTML and JavaScript fragments to specified nodes.\n * Callbacks called by this AMD module are responsible for doing the appropriate security checks\n * to access the information that is returned. This only does minimal validation on the context.\n *\n * @method fragmentAppend\n * @param {string} component Component where callback is located.\n * @param {string} callback Callback function name.\n * @param {integer} contextid Context ID of the fragment.\n * @param {object} params Parameters for the callback.\n * @return {Deferred} new promise that is resolved with the html and js.\n */\nconst loadFragment = (component, callback, contextid, params) => {\n    const promise = $.Deferred();\n\n    innerLoadFragment(component, callback, contextid, params)\n    .then(({html, javascript}) => {\n        return promise.resolve(html, processCollectedJavascript(javascript));\n    })\n    .catch((error) => {\n        promise.reject(error);\n    });\n\n    return promise.promise();\n};\n\nexport default {\n    processCollectedJavascript,\n    loadFragment,\n};\n"],"names":["obj","_jquery","__esModule","default","innerLoadFragment","component","callback","contextid","params","args","Array","from","Object","entries","formatParams","map","_ref","name","value","fetchOne","processCollectedJavascript","js","getList","$","scriptNode","_scriptNode$tagName","tagName","toLowerCase","hasAttribute","text","document","querySelectorAll","some","script","getAttribute","concat","encodeURI","filter","join","_default","loadFragment","promise","Deferred","then","_ref2","html","javascript","resolve","catch","error","reject","_exports"],"mappings":"wHAuBuB,IAAAA;;;;;;;;qFAAvBC,SAAuBD,IAAvBC,UAAuBD,IAAAE,WAAAF,IAAAG,CAAAA,QAAAH,KAIvB,MAqBMI,kBAAoBA,CAACC,UAAWC,SAAUC,UAAWC,UAEvD,MAAMC,KAvBYD,SACH,OAAXA,OACO,GAGW,iBAAXA,OACAE,MAAMC,KAAKC,OAAOC,QAAQL,SAG9B,GAcMM,CAAaN,QAAQO,KAAIC,OAAA,IAAEC,KAAMC,OAAMF,KAAA,MAAM,CACtDC,UACAC,YACH,IAED,OAAO,EAAAC,OAAAA,UAAS,oBAAqB,CACjCd,oBACAC,kBACAC,oBACAE,WACF,EASAW,2BAA8BC,KAClB,EAAAC,WAAOA,UAAC,EAAAC,QAACpB,SAACkB,KACXN,KAAKS,aAAe,IAAAC,oBAC7B,MAAMC,QAA4B,QAArBD,oBAAGD,WAAWE,eAAO,IAAAD,yBAAA,EAAlBA,oBAAoBE,cACpC,IAAKD,SAAuB,WAAZA,QACZ,OAAO,KAGX,IAAKF,WAAWI,aAAa,OACzB,OAAOJ,WAAWK,KAStB,OALWnB,MAAMC,KAAK,IAAImB,SAASC,iBAAiB,YAAYC,MAAMC,QACvDA,OAAOC,aAAa,SAAWV,WAAWU,aAAa,SAK3D,KAEXC,2IAAAA,OAG4BC,UAAUZ,WAAWU,aAAa,QAAO,2FAAA,IAIxEG,QAAQJ,UAAaA,SACrBK,KAAK,KA2BR,IAAAC,SAEa,CACXnB,sDACAoB,aAhBiBA,CAACnC,UAAWC,SAAUC,UAAWC,UAClD,MAAMiC,QAAUlB,QAACpB,QAACuC,WAUlB,OARAtC,kBAAkBC,UAAWC,SAAUC,UAAWC,QACjDmC,MAAKC,QAAwB,IAAvBC,KAACA,KAAIC,WAAEA,YAAWF,MACrB,OAAOH,QAAQM,QAAQF,KAAMzB,2BAA2B0B,YAAY,IAEvEE,OAAOC,QACJR,QAAQS,OAAOD,MAAM,IAGlBR,QAAQA,SAAS,GAM3B,OAAAU,SAAAhD,QAAAoC,SAAAY,SAAAhD,OAAA"}