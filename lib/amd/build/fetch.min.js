define("core/fetch",["exports","core/config","core/log","core/url","core/pending"],(function(_exports,_config,_log,_url,_pending){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}
/**
   * A wrapper around the browser Fetch API to be used with the Moodle Web Services.
   *
   * @module     core/fetch
   * @copyright  2022 Andrew Lyons < andrew@nicols.co.uk>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   * @since      4.2
   */Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.fetchOne=_exports.fetchMany=void 0,_config=_interopRequireDefault(_config),_log=_interopRequireDefault(_log),_url=_interopRequireDefault(_url),_pending=_interopRequireDefault(_pending);let unloading=!1;window.addEventListener("beforeunload",(()=>{unloading=!0}));const getServiceUrl=(loginRequired,cacheKey)=>{const serviceUrl=new URL(loginRequired?"service.php":"service-nologin.php","".concat(_config.default.wwwroot,"/lib/ajax/"));return loginRequired?serviceUrl.searchParams.set("sesskey",_config.default.sesskey):cacheKey&&serviceUrl.searchParams.set("cachekey",cacheKey),serviceUrl},getMethod=(loginRequired,cacheKey)=>!loginRequired&&cacheKey?"GET":"POST",getCacheKey=function(){let cacheKey=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(cacheKey){const key=parseInt(cacheKey);return key<=0||!key?null:key}return null};_exports.fetchOne=function(methodname,args){let loginRequired=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],options=arguments.length>3?arguments[3]:void 0;return fetchMany([{methodname:methodname,args:args}],loginRequired,options)[0]};const fetchMany=function(queries){let loginRequired=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],{updateSession:updateSession=!0,timeout:timeout=0,cacheKey:cacheKey=null}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const requestData=[],resolvers=new Map,promises=queries.map(((request,index)=>new Promise(((resolve,reject)=>{const{methodname:methodname,args:args}=request;requestData.push({index:index,methodname:methodname,args:args}),resolvers.set(index,{resolve:resolve,reject:reject})})))),serviceUrl=getServiceUrl(loginRequired,getCacheKey(cacheKey));return updateSession||serviceUrl.searchParams.set("nosessionupdate",!0),serviceUrl.searchParams.set("info",getRequestSummary(queries)),fetchRequests(serviceUrl,requestData,resolvers,loginRequired,updateSession,timeout,cacheKey),promises};_exports.fetchMany=fetchMany;const getRequestSummary=requests=>requests.length<=5?requests.map((request=>request.methodname)).sort().join():"".concat(requests.length,"-method-calls"),fetchRequests=async(serviceUrl,requests,resolvers,loginRequired,updateSession,timeout,cacheKey)=>{const options={method:getMethod(loginRequired,cacheKey),headers:[["Content-Type","application/json"]]};"GET"===options.method&&(serviceUrl.searchParams.set("args",JSON.stringify(requests)),serviceUrl.toString().length>2e3&&(options.method="POST",serviceUrl.searchParams.delete("args"))),"POST"===options.method&&(serviceUrl.searchParams.delete("cachekey"),options.body=JSON.stringify(requests));const{abortController:abortController,abortTimer:abortTimer}=(timeout=>{if(timeout<=0)return{abortTimer:null,abortController:null};const abortController=new AbortController;return{abortTimer:setTimeout((()=>{abortController.abort()}),1e3*timeout),abortController:abortController}})(timeout);abortController&&(options.signal=abortController);const pendingPromise=new _pending.default("core/fetch:fetchRequests");try{const response=await fetch(serviceUrl,options);clearTimeout(abortTimer),handleResponses(updateSession,response,resolvers)}catch(error){clearTimeout(abortTimer),handleFailure(resolvers,error)}finally{pendingPromise.resolve()}},handleFailure=(resolvers,error)=>{if(unloading)_log.default.error("Page unloaded - exception ignored: ".concat(error));else try{resolvers.forEach((_ref=>{let{reject:reject}=_ref;return reject(error)}))}catch{}},handleResponses=async(updateSession,response,resolvers)=>{const responseData=await response.json();if(responseData.error)throw new Error(responseData.error);return responseData.some(((response,index)=>response.error?(((exception,updateSession)=>{"servicerequireslogin"===exception.errorcode&&updateSession&&(window.location=_url.default.relativeUrl("/login/index.php"))})(response.exception,updateSession),resolvers.forEach((_ref2=>{let{reject:reject}=_ref2;return reject(response.exception)})),!0):(resolvers.get(index).resolve(response.data),resolvers.delete(index),!1))),responseData}}));

//# sourceMappingURL=fetch.min.js.map