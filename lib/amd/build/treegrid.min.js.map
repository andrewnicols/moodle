{"version":3,"file":"treegrid.min.js","sources":["../src/treegrid.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * An implementation of the TreeGrid design pattern.\n *\n * Note: The table must be configured correctly with all relevant ARIA attributes already set, including:\n * - aria-expanded\n * - aria-level\n * - aria-hidden\n *\n * @see https://www.w3.org/WAI/ARIA/apg/patterns/treegrid\n *\n * @module     core/treegrid\n * @copyright  2023 Andrew Lyons <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n *\n * @example <caption>Example of creating a new TreeGrid.</caption>\n * import TreeGrid from 'core/treegrid;\n *\n * new TreeGrid(document.querySelector('#my-table'));\n */\n\nimport AriaSelectors from 'core/local/aria/selectors';\n\n/**\n * The TreeGrid class.\n *\n * Note: Once instantiated, it is not expected that any further configuration of the table will be required.\n * Therefore the entire API is considered private.\n *\n * @class TreeGrid\n */\nexport default class TreeGrid {\n    /**\n     * Create an instance of the TreeGrid for the specified Table.\n     *\n     * @param {HTMLTableElement} treeElement The table to apply the treegrid to.\n     * @returns {TreeGrid}\n     * @example <caption>Example of creating a new TreeGrid using the static helper.</caption>\n     * import TreeGrid from 'core/treegrid;\n     *\n     * TreeGrid.createTreeGrid(document.querySelector('#my-table'));\n     *\n     * @example <caption>Example of creating a new TreeGrid using the static helper from PHP.</caption>\n     * $PAGE->requires->js_call_amd('core/treegrid', 'createTreeGrid', ['#my-table']);\n     */\n    static createTreeGrid(\n        treeElement,\n    ) {\n        return new TreeGrid(\n            treeElement,\n        );\n    }\n\n    /**\n     * @property {HTMLElement} treeElement The table to apply the treegrid to.\n     * @private\n     */\n    treeElement;\n\n    constructor(\n        treeElement,\n    ) {\n        this.treeElement = treeElement;\n        this.registerEventListeners();\n        this.initialiseAttributes();\n    }\n\n    initialiseAttributes() {\n        this.treeElement.querySelectorAll(AriaSelectors.elements.focusable).forEach((element) => {\n            // Makes the element focusable without including it in the tab sequence of the page.\n            element.setAttribute('tabindex', '-1');\n        });\n\n        Array.from(this.treeElement.querySelectorAll('tr')).reverse().forEach((rowElement) => {\n            rowElement.setAttribute('tabindex', '-1');\n        });\n\n        // Includes the element in the tab sequence.\n        // Only one row or gridcell in the treegrid has tabindex = \"0\".\n        // In this implementation, the first row in the treegrid is included in the tab sequence when the page loads.\n        // When the user moves focus in the treegrid, the element included in the tab sequence changes to the element\n        // with focus as described in the practice for Managing Focus Within Components Using a Roving tabindex.\n        // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex\n        this.getFirstRow().setAttribute('tabindex', '0');\n    }\n\n    registerEventListeners() {\n        this.treeElement.addEventListener('keydown', this.handleKeyDown.bind(this));\n        this.treeElement.addEventListener('click', this.handleClick.bind(this));\n        this.treeElement.addEventListener('focusin', this.handleFocusIn.bind(this));\n    }\n\n    shouldHandleEvent(eventTarget) {\n        const nearestElementWithRole = eventTarget.closest('[role]');\n        if (nearestElementWithRole !== this.treeElement) {\n            return false;\n        }\n\n        return true;\n    }\n\n    handleFocusIn(event) {\n        // Get the focused item.\n        const focusedItem = event.target;\n        if (!this.shouldHandleEvent(focusedItem)) {\n            return;\n        }\n\n        // Get all items currently with a tabindex.\n        const itemsWithTabIndex = Array.from(this.treeElement.querySelectorAll('[tabindex=\"0\"]'));\n        itemsWithTabIndex.filter((item) => item !== focusedItem).forEach((item) => {\n            // Remove the tabindex from all items except the focused item.\n            item.setAttribute('tabindex', -1);\n        });\n    }\n\n    handleClick(event) {\n        // Get the focusable element that was focused on.\n        const clickedItem = event.target;\n        if (!this.shouldHandleEvent(clickedItem)) {\n            return;\n        }\n\n        const focusableParent = clickedItem.closest('input:not([type=\"hidden\"]), a[href], button, textarea, select');\n        if (focusableParent) {\n            // If the clicked element is focusable, then focus on it.\n            this.focus(focusableParent);\n\n            // Do not prevent default. If the item clicked was actionable, that action should be respected.\n            return;\n        }\n\n        const tabbableParent = clickedItem.closest(AriaSelectors.elements.tabbable);\n        if (tabbableParent) {\n            // If the clicked element is tabbable, then focus on it.\n            this.focus(tabbableParent);\n\n            // Do not prevent default. If the item clicked was actionable, that action should be respected.\n            return;\n        }\n    }\n\n    handleKeyDown(event) {\n        if (!this.shouldHandleEvent(event.target)) {\n            return;\n        }\n\n        // https://www.w3.org/WAI/ARIA/apg/patterns/treegrid/#keyboardinteraction\n        if (event.key === 'Enter') {\n            this.handleKeyEnter(event);\n            return;\n        }\n\n        if (event.key === 'Tab') {\n            this.handleKeyTab(event);\n            return;\n        }\n\n        if (event.key === 'ArrowRight') {\n            this.handleKeyArrowRight(event);\n            return;\n        }\n\n        if (event.key === 'ArrowLeft') {\n            this.handleKeyArrowLeft(event);\n            return;\n        }\n\n        if (event.key === 'ArrowUp') {\n            this.handleKeyArrowUp(event);\n            return;\n        }\n\n        if (event.key === 'ArrowDown') {\n            this.handleKeyArrowDown(event);\n            return;\n        }\n\n        if (event.key === 'Home') {\n            if (event.ctrlKey) {\n                this.handleKeyControlHome(event);\n                return;\n            } else {\n                this.handleKeyHome(event);\n                return;\n            }\n        }\n\n        if (event.key === 'End') {\n            if (event.ctrlKey) {\n                this.handleKeyControlEnd(event);\n                return;\n            } else {\n                this.handleKeyEnd(event);\n                return;\n            }\n        }\n    }\n\n    handleKeyEnter(event) {\n        // If cell-only focus is enabled and focus is on the first cell with the aria-expanded property,\n        // opens or closes the child rows.\n        if (this.cellOnlyFocusEnabled()) {\n            event.preventDefault();\n        }\n\n        // Otherwise, performs the default action for the cell.\n    }\n\n    handleKeyTab(event) {\n        const focusedItem = this.getFocusedItem();\n        const row = this.getRowForItem(focusedItem);\n        // If the row containing focus contains focusable elements (e.g., inputs, buttons, links, etc.),\n        // moves focus to the next input in the row.\n        const focusableRowElements = this.getFocusableElements(row);\n\n        if (focusableRowElements.length > 0) {\n            const focusedItem = this.getFocusedItem();\n            const focusedItemIndex = focusableRowElements.indexOf(focusedItem);\n\n            if (focusedItemIndex !== -1) {\n                // The focused item is a focusable element in the row.\n                // Find the next item in the row which is not just a cell.\n                const getPossibleItems = () => {\n                    if (event.shiftKey) {\n                        return focusableRowElements.slice(0, focusedItemIndex).reverse();\n                    }\n                    return focusableRowElements.slice(focusedItemIndex + 1);\n                };\n                const nextItem = getPossibleItems().find((item) => {\n                    return item.matches('input:not([type=\"hidden\"]), a[href], button, textarea, select');\n                });\n\n\n                if (nextItem) {\n                    event.preventDefault();\n                    this.focus(nextItem);\n                    return;\n                }\n            }\n\n            // If focus is on the last focusable element in the row,\n            // moves focus out of the treegrid widget to the next focusable element.\n            return;\n        }\n    }\n\n    handleKeyArrowRight(event) {\n        const focusedItem = this.getFocusedItem();\n        const isRow = this.isRow(focusedItem);\n        const isCell = this.isCell(focusedItem);\n\n        if (isRow) {\n            // If focus is on a collapsed row, expands the row.\n            if (this.isRowCollapsed(focusedItem)) {\n                event.preventDefault();\n                this.expandRow(focusedItem);\n                return;\n            }\n\n            // If focus is on an expanded row or is on a row that does not have child rows,\n            // moves focus to the first cell in the row.\n            if (this.isRowExpanded(focusedItem) || this.isRow(focusedItem)) {\n                event.preventDefault();\n                this.focusFirstCell(focusedItem);\n                return;\n            }\n        }\n\n        if (isCell) {\n            const cell = this.getCellWithItem(focusedItem);\n            // If focus is on the right-most cell in a row, focus does not move.\n            if (!cell.nextElementSibling) {\n                return;\n            }\n\n            // If focus is on any other cell, moves focus one cell to the right.\n            this.focusNextCell(cell);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyArrowLeft(event) {\n        const focusedItem = this.getFocusedItem();\n        const isRow = this.isRow(focusedItem);\n        const isCell = this.isCell(focusedItem);\n\n        if (isRow) {\n            // If focus is on an expanded row, collapses the row.\n            if (this.isRowExpanded(focusedItem)) {\n                event.preventDefault();\n                this.collapseRow(focusedItem);\n                return;\n            }\n\n            // If focus is on a collapsed row or on a row that does not have child rows, focus does not move.\n            // Note: The TreeGrid example has an extra point:\n            // https://www.w3.org/WAI/ARIA/apg/patterns/treegrid/examples/treegrid-1/#kbd_label\n            // If a row is focused, and it is collapsed, moves to the parent row (if there is one).\n            if (this.isRowCollapsed(focusedItem) || !this.isRowCollapseSupported(focusedItem)) {\n                // Attempt to find the parent.\n                const parentRow = this.getParentRow(focusedItem);\n                if (parentRow) {\n                    event.preventDefault();\n                    this.focus(parentRow);\n                }\n                return;\n            }\n        }\n\n        if (isCell) {\n            const cell = this.getCellWithItem(focusedItem);\n            if (cell.previousElementSibling === null) {\n                if (this.rowFocusSupported()) {\n                    // If focus is on the first cell in a row and row focus is supported, moves focus to the row.\n                    event.preventDefault();\n                    this.focusCurrentRow(focusedItem);\n                    return;\n                } else {\n                    // If focus is on the first cell in a row and row focus is not supported, focus does not move.\n                    return;\n                }\n            }\n\n            // If focus is on any other cell, moves focus one cell to the left.\n            this.focusPreviousCell(cell);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyArrowUp(event) {\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus one row up.\n        if (this.isRow(focusedItem)) {\n            if (focusedItem.previousElementSibling === null) {\n                // If focus is on the first row, focus does not move.\n                return;\n            }\n            this.focusRowAbove(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        // If focus is on a cell, moves focus one cell up.\n        if (this.isCell(focusedItem)) {\n            const owningRow = this.getRowForItem(focusedItem);\n            if (owningRow.previousElementSibling === null) {\n                // If focus is on the top cell in the column, focus does not move.\n                return;\n            }\n            this.focusCellAbove(focusedItem);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyArrowDown(event) {\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus one row down.\n        if (this.isRow(focusedItem)) {\n            if (focusedItem.nextElementSibling === null) {\n                // If focus is on the last row, focus does not move.\n                return;\n            }\n            this.focusRowBelow(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        // If focus is on a cell, moves focus one cell down.\n        if (this.isCell(focusedItem)) {\n            const owningRow = this.getRowForItem(focusedItem);\n            if (owningRow.nextElementSibling === null) {\n                // If focus is on the bottom cell in the column, focus does not move.\n                return;\n            }\n            this.focusCellBelow(focusedItem);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyHome(event) {\n        // TODO Check these.\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus to the first row.\n        if (this.isRow(focusedItem)) {\n            const row = this.getRowForItem(focusedItem);\n            if (row.previousElementSibling === null) {\n                // If focus is in the first row, focus does not move.\n                return;\n            }\n            this.focusFirstRow(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        if (this.isCell(focusedItem)) {\n            const cell = this.getCellWithItem(focusedItem);\n            // If focus is on a cell, moves focus to the first cell in the row.\n            if (cell.previousElementSibling === null) {\n                // If focus is in the first cell of the row, focus does not move.\n                return;\n            }\n            this.focusFirstCell(focusedItem);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyEnd(event) {\n        // TODO Check these.\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus to the last row.\n        if (this.isRow(focusedItem)) {\n            const row = this.getRowForItem(focusedItem);\n            if (row.nextElementSibling === null) {\n                // If focus is in the last row, focus does not move.\n                return;\n            }\n            this.focusLastRow(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        if (this.isCell(focusedItem)) {\n            const cell = this.getCellWithItem(focusedItem);\n            // If focus is on a cell, moves focus to the last cell in the row.\n            if (cell.nextElementSibling === null) {\n                // If focus is in the last cell of the row, focus does not move.\n                return;\n            }\n            this.focusLastCell(focusedItem);\n            event.preventDefault();\n        }\n    }\n\n    handleKeyControlHome(event) {\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus to the first row.\n        if (this.isRow(focusedItem)) {\n            const row = this.getRowForItem(focusedItem);\n            if (row.previousElementSibling === null) {\n                // If focus is in the first row, focus does not move.\n                return;\n            }\n            this.focusFirstRow(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        // If focus is on a cell, moves focus to the first cell in the column.\n        // Note: There is a bug in the spec here. This should be the first _row_, not the first _cell_ in the column.\n        // Corrected text follows.\n        // https://github.com/w3c/aria-practices/pull/2779\n        // If focus is on a cell, moves focus to the cell in the first row in the same column as the cell that had focus.\n        if (this.isCell(focusedItem)) {\n            if (this.isFirstRow(focusedItem)) {\n                // If focus is in the first row, focus does not move.\n                return;\n            }\n            this.focusSameCellInRow(focusedItem, this.getFirstRow());\n            event.preventDefault();\n        }\n    }\n\n    handleKeyControlEnd(event) {\n        const focusedItem = this.getFocusedItem();\n\n        // If focus is on a row, moves focus to the last row.\n        if (this.isRow(focusedItem)) {\n            const row = this.getRowForItem(focusedItem);\n            if (row.nextElementSibling === null) {\n                // If focus is in the last row, focus does not move.\n                return;\n            }\n            this.focusLastRow(focusedItem);\n            event.preventDefault();\n            return;\n        }\n\n        // If focus is on a cell, moves focus to the last cell in the column.\n        // Note: There is a bug in the spec here. This should be the last _row_, not the last _cell_ in the column.\n        // Corrected text follows.\n        // https://github.com/w3c/aria-practices/pull/2779\n        // If focus is on a cell, moves focus to the cell in the last row in the same column as the cell that had focus.\n        if (this.isCell(focusedItem)) {\n            if (this.isLastRow(focusedItem)) {\n                // If focus is in the last row, focus does not move.\n                return;\n            }\n            this.focusSameCellInRow(focusedItem, this.getLastRow());\n            event.preventDefault();\n        }\n    }\n\n    getFocusedItem() {\n        return document.activeElement;\n    }\n\n    getFocusableElements(\n        parent,\n        {\n            includeTabIndex = false,\n        } = {}\n    ) {\n        if (includeTabIndex) {\n            return Array.from(parent.querySelectorAll(\n                'input:not([type=\"hidden\"]), a[href], button, textarea, select, [tabindex]'\n            ));\n        }\n        return Array.from(parent.querySelectorAll(\n            'input:not([type=\"hidden\"]), a[href], button, textarea, select'\n        ));\n    }\n\n    isRow(item) {\n        return !!item.matches('tr');\n    }\n\n    isFirstRow(item) {\n        const row = this.getRowForItem(item);\n        return row === this.getFirstRow();\n    }\n\n    isLastRow(item) {\n        const row = this.getRowForItem(item);\n        return row === this.getLastRow();\n    }\n\n    isCell(item) {\n        return !!this.getCellWithItem(item);\n    }\n\n    focusCell(cell) {\n        // Check for focusable child such as link or textbox\n        // and use that if available\n        const focusableChildren = this.getFocusableElements(cell);\n        this.focus(focusableChildren[0] || cell);\n    }\n\n    focus(item) {\n        // Ensure focusable.\n        item.tabIndex = 0;\n        item.focus({\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#focusvisible\n            // Note: this is an experimental feature.\n            focusVisible: true,\n        });\n    }\n\n    getRowForItem(item) {\n        return item.closest('tr');\n    }\n\n    isRowExpanded(item) {\n        // Note: We check for an exact value because not all rows support expansion.\n        const row = this.getRowForItem(item);\n        return row.getAttribute('aria-expanded') === 'true';\n    }\n\n    isRowCollapsed(item) {\n        // Note: We check for an exact value because not all rows support expansion.\n        const row = this.getRowForItem(item);\n        return row.getAttribute('aria-expanded') === 'false';\n    }\n\n    isRowCollapseSupported(item) {\n        const row = this.getRowForItem(item);\n        return row.getAttribute('aria-expanded') !== null;\n    }\n\n    expandRow(item) {\n        const row = this.getRowForItem(item);\n        row.setAttribute('aria-expanded', true);\n        this.getChildRows(row).forEach((childRow) => {\n            childRow.setAttribute('aria-hidden', false);\n        });\n    }\n\n    collapseRow(item) {\n        const row = this.getRowForItem(item);\n        this.getChildRows(row).forEach((childRow) => {\n            childRow.setAttribute('aria-hidden', true);\n        });\n        row.setAttribute('aria-expanded', false);\n    }\n\n    getChildRows(parent) {\n        const parentRow = this.getRowForItem(parent);\n        const parentRowLevel = this.getRowLevel(parentRow);\n\n        const allRows = this.getAllRows();\n        const parentRowIndex = allRows.indexOf(parentRow);\n\n        const possibleChildren = allRows.slice(parentRowIndex + 1);\n        const childRows = [];\n        for (const childRow of possibleChildren) {\n            if (this.getRowLevel(childRow) === parentRowLevel + 1) {\n                childRows.push(childRow);\n            } else {\n                break;\n            }\n        }\n\n        return childRows;\n    }\n\n    getParentRow(child) {\n        const childRow = this.getRowForItem(child);\n        const childRowLevel = this.getRowLevel(childRow);\n\n        const allRows = this.getAllRows();\n        const childRowIndex = allRows.indexOf(childRow);\n        const possibleParents = allRows.slice(0, childRowIndex).reverse();\n        for (const parentRow of possibleParents) {\n            if (this.getRowLevel(parentRow) === childRowLevel - 1) {\n                return parentRow;\n            }\n        }\n        return null;\n    }\n\n    getCellWithItem(item) {\n        return item.closest('td');\n    }\n\n    getNavigableRows() {\n        // Fetch all TR elements which are not in a THEAD.\n        return this.getAllRows()\n            .filter((row) => row.matches(':not([aria-hidden=\"true\"]'));\n    }\n\n    getAllRows() {\n        // Fetch all TR elements which are not in a THEAD.\n        return Array.from(this.treeElement.querySelectorAll('tr'))\n            .filter((row) => !row.closest('thead'));\n    }\n\n    getNavigableColumns(row) {\n        return Array.from(row.getElementsByTagName('td'));\n    }\n\n    getFirstRow() {\n        return this.getNavigableRows()?.shift();\n    }\n\n    getLastRow() {\n        return this.getNavigableRows()?.pop();\n    }\n\n    getPreviousRow(item) {\n        const allRows = this.getNavigableRows();\n        const currentRow = this.getRowForItem(item);\n\n        const index = allRows.indexOf(currentRow);\n        if (index === 0) {\n            return null;\n        }\n\n        return allRows[index - 1];\n    }\n\n    getNextRow(item) {\n        const allRows = this.getNavigableRows();\n        const currentRow = this.getRowForItem(item);\n\n        const index = allRows.indexOf(currentRow);\n        if (index >= allRows.length - 1) {\n            return null;\n        }\n\n        return allRows[index + 1];\n    }\n\n    focusSameCellInRow(currentItem, targetRow) {\n        if (!targetRow) {\n            // The target row does nto exist.\n            return;\n        }\n        const currentRow = this.getRowForItem(currentItem);\n        const currentCols = this.getNavigableColumns(currentRow);\n        const currentIndex = currentCols.indexOf(this.getCellWithItem(currentItem));\n\n        const targetCols = this.getNavigableColumns(targetRow);\n        this.focusCell(targetCols[currentIndex]);\n    }\n\n    focusCellAbove(item) {\n        this.focusSameCellInRow(item, this.getPreviousRow(item));\n    }\n\n    focusCellBelow(item) {\n        this.focusSameCellInRow(item, this.getNextRow(item));\n    }\n\n    focusCurrentRow(rowChild) {\n        this.focus(this.getRowForItem(rowChild));\n    }\n\n    focusRowAbove(item) {\n        this.focus(this.getPreviousRow(item));\n    }\n\n    focusRowBelow(item) {\n        this.focus(this.getNextRow(item));\n    }\n\n    focusFirstRow() {\n        this.focus(this.getFirstRow());\n    }\n\n    focusLastRow() {\n        this.focus(this.getLastRow());\n    }\n\n    focusFirstCell(item) {\n        const row = this.getRowForItem(item);\n        this.focusCell(row.querySelector('td'));\n    }\n\n    focusLastCell(item) {\n        const row = this.getRowForItem(item);\n        const cells = this.getNavigableColumns(row);\n        this.focusCell(cells[cells.length - 1]);\n    }\n\n    focusFirstCellInRow(item) {\n        const row = this.getRowForItem(item);\n        const cells = this.getNavigableColumns(row);\n        this.focusCell(cells[0]);\n    }\n\n    focusLastCellInRow(item) {\n        this.focusLastCell(this.getRowForItem(item));\n    }\n\n    focusNextCell(item) {\n        this.focusCell(item.nextElementSibling);\n    }\n\n    focusPreviousCell(item) {\n        this.focusCell(item.previousElementSibling);\n    }\n\n    cellOnlyFocusEnabled() {\n        // We do not currently supported cell-only focus.\n        return false;\n    }\n\n    rowFocusSupported() {\n        if ('focusRows' in this.treeElement.dataset) {\n            return this.treeElement.dataset.focusRows !== \"false\";\n        }\n        return true;\n    }\n\n    getRowLevel(row) {\n        return parseInt(row.getAttribute('aria-level'));\n    }\n}\n"],"names":["TreeGrid","treeElement","constructor","registerEventListeners","initialiseAttributes","querySelectorAll","AriaSelectors","elements","focusable","forEach","element","setAttribute","Array","from","this","reverse","rowElement","getFirstRow","addEventListener","handleKeyDown","bind","handleClick","handleFocusIn","shouldHandleEvent","eventTarget","closest","event","focusedItem","target","filter","item","clickedItem","focusableParent","focus","tabbableParent","tabbable","key","ctrlKey","handleKeyControlHome","handleKeyHome","handleKeyControlEnd","handleKeyEnd","handleKeyArrowDown","handleKeyArrowUp","handleKeyArrowLeft","handleKeyArrowRight","handleKeyTab","handleKeyEnter","cellOnlyFocusEnabled","preventDefault","getFocusedItem","row","getRowForItem","focusableRowElements","getFocusableElements","length","focusedItemIndex","indexOf","nextItem","shiftKey","slice","getPossibleItems","find","matches","isRow","isCell","isRowCollapsed","expandRow","isRowExpanded","focusFirstCell","cell","getCellWithItem","nextElementSibling","focusNextCell","collapseRow","isRowCollapseSupported","parentRow","getParentRow","previousElementSibling","rowFocusSupported","focusCurrentRow","focusPreviousCell","focusRowAbove","focusCellAbove","focusRowBelow","focusCellBelow","focusFirstRow","focusLastRow","focusLastCell","isFirstRow","focusSameCellInRow","isLastRow","getLastRow","document","activeElement","parent","includeTabIndex","focusCell","focusableChildren","tabIndex","focusVisible","getAttribute","getChildRows","childRow","parentRowLevel","getRowLevel","allRows","getAllRows","parentRowIndex","possibleChildren","childRows","push","child","childRowLevel","childRowIndex","possibleParents","getNavigableRows","getNavigableColumns","getElementsByTagName","_this$getNavigableRow","shift","_this$getNavigableRow2","pop","getPreviousRow","currentRow","index","getNextRow","currentItem","targetRow","currentIndex","targetCols","rowChild","querySelector","cells","focusFirstCellInRow","focusLastCellInRow","dataset","focusRows","parseInt"],"mappings":"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"}