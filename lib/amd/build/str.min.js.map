{"version":3,"file":"str.min.js","sources":["../src/str.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Fetch and return language strings.\n *\n * @module     core/str\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      2.9\n *\n */\nimport $ from 'jquery';\nimport Ajax from 'core/ajax';\nimport LocalStorage from 'core/localstorage';\n\n// Module cache for the promises so that we don't make multiple\n// unnecessary requests.\nlet promiseCache = [];\n\nconst defaultStringResolver = (stringRequests) => {\n    const requestData = stringRequests.map(({\n        key,\n        component,\n        lang,\n    }) => ({\n        methodname: 'core_get_string',\n        args: {\n            stringid: key,\n            stringparams: [],\n            component,\n            lang,\n        },\n    }));\n\n    return Ajax.call(requestData, true, false, false, 0, M.cfg.langrev);\n};\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * Return a Promise that resolves to a string.\n *\n * If the string has previously been cached, then the Promise will be resolved immediately, otherwise it will be fetched\n * from the server and resolved when available.\n *\n * @method get_string\n * @param {string} key The language string key\n * @param {string} component The language string component\n * @param {string} param The param for variable expansion in the string.\n * @param {string} lang The users language - if not passed it is deduced.\n * @return {Promise}\n *\n * @example <caption>Fetching a string</caption>\n *\n * import {get_string as getString} from 'core/str';\n * get_string('cannotfindteacher', 'error')\n * .then(str => {\n *     window.console.log(str); // Cannot find teacher\n * })\n * .catch();\n */\n// eslint-disable-next-line camelcase\nexport const get_string = (key, component, param, lang) => {\n    return get_strings([{key, component, param, lang}])\n        .then(results => results[0]);\n};\n\nlet stringResolver = defaultStringResolver;\n\nexport const getStringResolver = () => stringResolver;\n\nexport const setStringResolver = (newStringResolver) => {\n    stringResolver = newStringResolver;\n};\n\nexport const resetPromiseCache = () => {\n    promiseCache = [];\n};\n\n/**\n * Make a batch request to load a set of strings.\n *\n * Any missing string will be fetched from the server.\n * The Promise will only be resolved once all strings are available, or an attempt has been made to fetch them.\n *\n * @method get_strings\n * @param {Object[]} requests List of strings to fetch\n * @param {string} requests.key The string identifer to fetch\n * @param {string} [requests.component='core'] The componet to fetch from\n * @param {string} [requests.lang] The language to fetch a string for. Defaults to current page language.\n * @param {object|string} [requests.param] The param for variable expansion in the string.\n * @return {Promise[]}\n *\n * @example <caption>Fetching a set of strings</caption>\n *\n * import {get_strings as getStrings} from 'core/str';\n * get_strings([\n *     {\n *         key: 'cannotfindteacher',\n *         component: 'error',\n *     },\n *     {\n *         key: 'yes',\n *         component: 'core',\n *     },\n *     {\n *         key: 'no',\n *         component: 'core',\n *     },\n * ])\n * .then((cannotFindTeacher, yes, no) => {\n *     window.console.log(cannotFindTeacher); // Cannot find teacher\n *     window.console.log(yes); // Yes\n *     window.console.log(no); // No\n * })\n * .catch();\n */\n// eslint-disable-next-line camelcase\nexport const get_strings = async (requests) => {\n    const requestData = [];\n    const requestResolvers = [];\n    const requestRejectors = [];\n    const pageLang = $('html').attr('lang').replace(/-/g, '_');\n    // Helper function to construct the cache key.\n    const getCacheKey = ({key, component = 'core', lang = pageLang}) => `core_str/${key}/${component}/${lang}`;\n\n    const stringPromises = requests.map((request) => {\n        const cacheKey = getCacheKey(request);\n        const {\n            component = 'core',\n            key,\n            param,\n            lang = pageLang,\n        } = request;\n        // Helper function to add the promise to cache.\n        const buildReturn = (promise) => {\n            // Make sure the promise cache contains our promise.\n            promiseCache[cacheKey] = promise;\n            return promise;\n        };\n\n        // Check if we can serve the string straight from M.str.\n        if (component in M.str && key in M.str[component]) {\n            return buildReturn(new Promise((resolve) => {\n                resolve(M.util.get_string(key, component, param, lang));\n            }));\n        }\n\n        // Check if the string is in the browser's local storage.\n        const cached = LocalStorage.get(cacheKey);\n        if (cached) {\n            M.str[component] = {...M.str[component], [key]: cached};\n            return buildReturn(new Promise((resolve) => {\n                resolve(M.util.get_string(key, component, param, lang));\n            }));\n        }\n\n        // Check if we've already loaded this string from the server.\n        if (cacheKey in promiseCache) {\n            return buildReturn(promiseCache[cacheKey]).then(() => {\n                return M.util.get_string(key, component, param, lang);\n            });\n        } else {\n            requestData.push({component, key, param, lang});\n            // We're going to have to ask the server for the string so\n            // add this string to the list of requests to be sent.\n            return buildReturn(new Promise((resolve, reject) => {\n                requestResolvers.push((str) => {\n                    // When we get the response from the server\n                    // we should update M.str and the browser's\n                    // local storage before resolving this promise.\n                    M.str[component] = { ...M.str[component], [key]: str };\n                    LocalStorage.set(cacheKey, str);\n                    resolve(M.util.get_string(key, component, param, lang));\n                });\n                requestRejectors.push(reject);\n            }));\n        }\n    });\n\n    if (requestData.length) {\n        // If we need to load any strings from the server then send\n        // off the request.\n        const stringResolver = getStringResolver();\n        const promises = await stringResolver(requestData);\n        Promise.all([...promises])\n            .then((responses) => {\n                responses.forEach((response, index) => {\n                    requestResolvers[index](response);\n                });\n                return responses;\n            })\n            .catch((error) => {\n                requestRejectors.forEach((reject) => {\n                    reject(error);\n                });\n            });\n    }\n\n    // We need to use jQuery here because some calling code uses the\n    // .done handler instead of the .then handler.\n    return $.when.apply($, stringPromises)\n        .then((...strings) => strings);\n};\n\n/**\n * Add a list of strings to the caches.\n *\n * This function should typically only be called from core APIs to pre-cache values.\n *\n * @method cache_strings\n * @protected\n * @param {Object[]} strings List of strings to fetch\n * @param {string} strings.key The string identifer to fetch\n * @param {string} strings.value The string value\n * @param {string} [strings.component='core'] The componet to fetch from\n * @param {string} [strings.lang] The language to fetch a string for. Defaults to current page language.\n */\n// eslint-disable-next-line camelcase\nexport const cache_strings = (strings) => {\n    const defaultLang = $('html').attr('lang').replace(/-/g, '_');\n\n    strings.forEach(({key, component, value, lang = defaultLang}) => {\n        const cacheKey = ['core_str', key, component, lang].join('/');\n\n        // Check M.str caching.\n        if (!(component in M.str) || !(key in M.str[component])) {\n            if (!(component in M.str)) {\n                M.str[component] = {};\n            }\n\n            M.str[component][key] = value;\n        }\n\n        // Check local storage.\n        if (!LocalStorage.get(cacheKey)) {\n            LocalStorage.set(cacheKey, value);\n        }\n\n        // Check the promises cache.\n        if (!(cacheKey in promiseCache)) {\n            promiseCache[cacheKey] = $.Deferred().resolve(value).promise();\n        }\n    });\n};\n/* eslint-enable no-restricted-properties */\n"],"names":["promiseCache","key","component","param","lang","get_strings","then","results","stringResolver","stringRequests","requestData","map","_ref","methodname","args","stringid","stringparams","Ajax","call","M","cfg","langrev","getStringResolver","newStringResolver","async","requestResolvers","requestRejectors","pageLang","attr","replace","stringPromises","requests","request","cacheKey","_ref2","getCacheKey","buildReturn","promise","str","Promise","resolve","util","get_string","cached","LocalStorage","get","push","reject","set","length","promises","all","responses","forEach","response","index","catch","error","$","when","apply","strings","defaultLang","_ref3","value","join","Deferred"],"mappings":"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"}