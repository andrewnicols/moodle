{"version":3,"file":"search.min.js","sources":["../src/search.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Allow the user to search for learners within the grader report.\n * Have to basically search twice on the dataset to avoid passing around massive csv params whilst allowing debouncing.\n *\n * @module    gradereport_grader/search\n * @copyright 2023 Mathew May <mathew.solutions>\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport Pending from 'core/pending';\nimport GradebookSearchClass from 'gradereport_grader/search/search_class';\nimport * as Repository from 'gradereport_grader/search/repository';\nimport {get_strings as getStrings} from 'core/str';\n\nconst bannedFilterFields = ['profileimageurlsmall', 'profileimageurl', 'id', 'link', 'matchingField', 'matchingFieldName'];\nlet profilestringmap = null;\n\n/**\n * Given the set of profile fields we can possibly search, fetch their strings,\n * so we can report to screen readers the field that matched.\n *\n * @returns {Promise<void>}\n */\nconst fetchRequiredStrings = () => {\n    const requiredStrings = [\n        'username',\n        'firstname',\n        'lastname',\n        'email',\n        'city',\n        'country',\n        'department',\n        'institution',\n        'idnumber',\n        'phone1',\n        'phone2',\n    ];\n    return getStrings(requiredStrings.map((key) => ({key})))\n        .then((stringArray) => new Map(\n            requiredStrings.map((key, index) => ([key, stringArray[index]]))\n        ));\n};\n\n/**\n * The hook into this module that calls off to the search component.\n *\n * @returns {Promise<void>}\n */\nexport const init = async() => {\n    const pendingPromise = new Pending();\n    profilestringmap = await fetchRequiredStrings();\n    new GradebookSearchClass(fetchFilterableData, filter, filterMatchIndicator);\n    pendingPromise.resolve();\n};\n\n/**\n * Get the data we will be searching against in this component.\n *\n * @param {Number} courseID The ID of the course to fetch users within.\n * @returns {Promise<*>}\n */\nconst fetchFilterableData = (courseID) => Repository.userFetch(courseID).then((r) => r.users);\n\n/**\n * Dictate to the search component how and what we want to match upon.\n *\n * @param {Array} dataset All of the learners to search within.\n * @param {String} searchTerm The term that the user is searching for.\n * @returns {Array} The users that match the given criteria.\n */\nconst filter = (dataset, searchTerm) => {\n    const preppedSearchTerm = searchTerm.toLowerCase();\n    return dataset.filter((user) => Object.keys(user).some((key) => {\n        if (user[key] === \"\" || bannedFilterFields.includes(key)) {\n            return false;\n        }\n        return user[key].toString().toLowerCase().includes(preppedSearchTerm);\n    }));\n};\n\n/**\n * Given we have a subset of the dataset, set the field that we matched upon to inform the end user.\n *\n * @param {Array} matchedResultsSubset The results we will render out.\n * @param {Function} selectOneLink The individual link to view only this participant.\n * @param {String} searchTerm The term that the user is searching for.\n * @returns {Array} The results with the matched fields inserted.\n */\nconst filterMatchIndicator = (matchedResultsSubset, selectOneLink, searchTerm) => {\n    const preppedSearchTerm = searchTerm.toLowerCase();\n    return matchedResultsSubset.map((user) => {\n        for (const [key, value] of Object.entries(user)) {\n            const valueString = value.toString().toLowerCase();\n            if (!valueString.includes(preppedSearchTerm)) {\n                continue;\n            }\n            // Ensure we have a good string, otherwise fallback to the key.\n            user.matchingFieldName = profilestringmap.get(key) ?? key;\n            user.matchingField = valueString.replace(\n                preppedSearchTerm,\n                `<span class=\"font-weight-bold\">${searchTerm}</span>`\n            );\n            user.link = selectOneLink(user.id);\n            break;\n        }\n        return user;\n    });\n};\n"],"names":["_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_interopRequireDefault","obj","__esModule","default","_pending","_search_class","Repository","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","bannedFilterFields","profilestringmap","_exports","init","async","pendingPromise","Pending","fetchRequiredStrings","requiredStrings","getStrings","map","then","stringArray","Map","index","GradebookSearchClass","fetchFilterableData","filter","filterMatchIndicator","resolve","courseID","userFetch","r","users","dataset","searchTerm","preppedSearchTerm","toLowerCase","user","keys","some","includes","toString","matchedResultsSubset","selectOneLink","value","entries","_profilestringmap$get","valueString","matchingFieldName","matchingField","replace","concat","link","id"],"mappings":"oNAyBmE,SAAAA,yBAAAC,aAAA,GAAA,mBAAAC,QAAA,OAAA,KAAA,IAAAC,kBAAAD,IAAAA,QAAAE,iBAAAF,IAAAA,eAAAF,yBAAA,SAAAC,aAAAA,OAAAA,YAAAG,iBAAAD,oBAAAF,YAAA,CAAA,SAAAI,uBAAAC,KAAAA,OAAAA,KAAAA,IAAAC,WAAAD,IAAAE,CAAAA,QAAAF,IAAA;;;;;;;;kFAFnEG,SAAAJ,uBAAAI,UACAC,cAAAL,uBAAAK,eACAC,WAAmE,SAAAL,IAAAL,aAAAA,IAAAA,aAAAK,KAAAA,IAAAC,WAAAD,OAAAA,IAAAA,GAAAA,OAAAA,KAAAA,iBAAAA,KAAAE,mBAAAF,IAAAE,MAAAA,CAAAA,QAAAF,KAAAM,IAAAA,MAAAZ,yBAAAC,aAAA,GAAAW,OAAAA,MAAAC,IAAAP,KAAA,OAAAM,MAAAE,IAAAR,KAAA,IAAAS,OAAAC,GAAAA,sBAAAC,OAAAC,gBAAAD,OAAAE,yBAAAC,IAAAA,IAAAA,OAAAd,IAAAc,eAAAA,KAAAH,OAAAI,UAAAC,eAAAC,KAAAjB,IAAAc,KAAA,CAAA,IAAAI,KAAAR,sBAAAC,OAAAE,yBAAAb,IAAAc,KAAAI,KAAAA,OAAAA,KAAAV,KAAAU,KAAAC,KAAAR,OAAAC,eAAAH,OAAAK,IAAAI,MAAAT,OAAAK,KAAAd,IAAAc,IAAAL,CAAAA,OAAAP,QAAAF,IAAAM,OAAAA,MAAAa,IAAAnB,IAAAS,eAAAA,MAAA,CAAnEW,CAAAf,YAGA,MAAMgB,mBAAqB,CAAC,uBAAwB,kBAAmB,KAAM,OAAQ,gBAAiB,qBACtG,IAAIC,iBAAmB,KAsCrBC,SAAAC,KALkBC,UAChB,MAAMC,eAAiB,IAAIC,SAAAA,QAC3BL,sBA3ByBM,MACzB,MAAMC,gBAAkB,CACpB,WACA,YACA,WACA,QACA,OACA,UACA,aACA,cACA,WACA,SACA,UAEJ,OAAO,EAAAC,kBAAWD,gBAAgBE,KAAKjB,MAAS,CAACA,aAC5CkB,MAAMC,aAAgB,IAAIC,IACvBL,gBAAgBE,KAAI,CAACjB,IAAKqB,QAAW,CAACrB,IAAKmB,YAAYE,YACzD,EAUmBP,GACzB,IAAIQ,sBAAqBC,oBAAqBC,OAAQC,sBACtDb,eAAec,SAAS,EAS5B,MAAMH,oBAAuBI,UAAapC,WAAWqC,UAAUD,UAAUT,MAAMW,GAAMA,EAAEC,QASjFN,OAASA,CAACO,QAASC,cACrB,MAAMC,kBAAoBD,WAAWE,cACrC,OAAOH,QAAQP,QAAQW,MAAStC,OAAOuC,KAAKD,MAAME,MAAMrC,KAClC,KAAdmC,KAAKnC,OAAeO,mBAAmB+B,SAAStC,MAG7CmC,KAAKnC,KAAKuC,WAAWL,cAAcI,SAASL,sBACpD,EAWDR,qBAAuBA,CAACe,qBAAsBC,cAAeT,cAC/D,MAAMC,kBAAoBD,WAAWE,cACrC,OAAOM,qBAAqBvB,KAAKkB,OAC7B,IAAK,MAAOnC,IAAK0C,SAAU7C,OAAO8C,QAAQR,MAAO,CAAA,IAAAS,sBAC7C,MAAMC,YAAcH,MAAMH,WAAWL,cACrC,GAAKW,YAAYP,SAASL,mBAA1B,CAIAE,KAAKW,kBAA6CF,QAA5BA,sBAAGpC,iBAAiBd,IAAIM,YAAI4C,IAAAA,sBAAAA,sBAAI5C,IACtDmC,KAAKY,cAAgBF,YAAYG,QAC7Bf,kBAAiBgB,kCAAAA,OACiBjB,WACrC,YACDG,KAAKe,KAAOT,cAAcN,KAAKgB,IAC/B,KARA,CASJ,CACA,OAAOhB,IAAI,GACb,CACJ"}