{"version":3,"file":"search.min.js","sources":["../src/search.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Allow the user to search for learners within the grader report.\n * Have to basically search twice on the dataset to avoid passing around massive csv params whilst allowing debouncing.\n *\n * @module    gradereport_grader/search\n * @copyright 2023 Mathew May <mathew.solutions>\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport Pending from 'core/pending';\nimport GradebookSearchClass from 'gradereport_grader/search/search_class';\nimport * as Repository from 'gradereport_grader/search/repository';\nimport {get_strings as getStrings} from 'core/str';\n\nconst bannedFilterFields = ['profileimageurlsmall', 'profileimageurl', 'id', 'link', 'matchingField', 'matchingFieldName'];\nlet profilestringmap = null;\n\n/**\n * Given the set of profile fields we can possibly search, fetch their strings,\n * so we can report to screen readers the field that matched.\n *\n * @returns {Promise<void>}\n */\nconst fetchRequiredStrings = () => {\n    const requiredStrings = [\n        'username',\n        'firstname',\n        'lastname',\n        'email',\n        'city',\n        'country',\n        'department',\n        'institution',\n        'idnumber',\n        'phone1',\n        'phone2',\n    ];\n    return getStrings(requiredStrings.map((key) => ({key})))\n        .then((stringArray) => new Map(\n            requiredStrings.map((key, index) => ([key, stringArray[index]]))\n        ));\n};\n\n/**\n * The hook into this module that calls off to the search component.\n *\n * @returns {Promise<void>}\n */\nexport const init = async() => {\n    const pendingPromise = new Pending();\n    profilestringmap = await fetchRequiredStrings();\n    new GradebookSearchClass(fetchFilterableData, filter, filterMatchIndicator);\n    pendingPromise.resolve();\n};\n\n/**\n * Get the data we will be searching against in this component.\n *\n * @param {Number} courseID The ID of the course to fetch users within.\n * @returns {Promise<*>}\n */\nconst fetchFilterableData = (courseID) => Repository.userFetch(courseID).then((r) => r.users);\n\n/**\n * Dictate to the search component how and what we want to match upon.\n *\n * @param {Array} dataset All of the learners to search within.\n * @param {String} searchTerm The term that the user is searching for.\n * @returns {Array} The users that match the given criteria.\n */\nconst filter = (dataset, searchTerm) => {\n    const preppedSearchTerm = searchTerm.toLowerCase();\n    return dataset.filter((user) => Object.keys(user).some((key) => {\n        if (user[key] === \"\" || bannedFilterFields.includes(key)) {\n            return false;\n        }\n        return user[key].toString().toLowerCase().includes(preppedSearchTerm);\n    }));\n};\n\n/**\n * Given we have a subset of the dataset, set the field that we matched upon to inform the end user.\n *\n * @param {Array} matchedResultsSubset The results we will render out.\n * @param {Function} selectOneLink The individual link to view only this participant.\n * @param {String} searchTerm The term that the user is searching for.\n * @returns {Array} The results with the matched fields inserted.\n */\nconst filterMatchIndicator = (matchedResultsSubset, selectOneLink, searchTerm) => {\n    const preppedSearchTerm = searchTerm.toLowerCase();\n    return matchedResultsSubset.map((user) => {\n        for (const [key, value] of Object.entries(user)) {\n            const valueString = value.toString().toLowerCase();\n            if (!valueString.includes(preppedSearchTerm)) {\n                continue;\n            }\n            // Ensure we have a good string, otherwise fallback to the key.\n            user.matchingFieldName = profilestringmap.get(key) ?? key;\n            user.matchingField = valueString.replace(\n                preppedSearchTerm,\n                `<span class=\"font-weight-bold\">${searchTerm}</span>`\n            );\n            user.link = selectOneLink(user.id);\n            break;\n        }\n        return user;\n    });\n};\n"],"names":["bannedFilterFields","profilestringmap","async","pendingPromise","Pending","requiredStrings","map","key","then","stringArray","Map","index","fetchRequiredStrings","GradebookSearchClass","fetchFilterableData","filter","filterMatchIndicator","resolve","courseID","Repository","userFetch","r","users","dataset","searchTerm","preppedSearchTerm","toLowerCase","user","Object","keys","some","includes","toString","matchedResultsSubset","selectOneLink","value","entries","valueString","matchingFieldName","get","matchingField","replace","link","id"],"mappings":";;;;;;;;01BA4BMA,mBAAqB,CAAC,uBAAwB,kBAAmB,KAAM,OAAQ,gBAAiB,yBAClGC,iBAAmB,mBAiCHC,gBACVC,eAAiB,IAAIC,iBAC3BH,sBA3ByB,YACnBI,gBAAkB,CACpB,WACA,YACA,WACA,QACA,OACA,UACA,aACA,cACA,WACA,SACA,iBAEG,oBAAWA,gBAAgBC,KAAKC,OAAUA,IAAAA,SAC5CC,MAAMC,aAAgB,IAAIC,IACvBL,gBAAgBC,KAAI,CAACC,IAAKI,QAAW,CAACJ,IAAKE,YAAYE,cAWtCC,OACrBC,sBAAqBC,oBAAqBC,OAAQC,sBACtDb,eAAec,iBASbH,oBAAuBI,UAAaC,WAAWC,UAAUF,UAAUV,MAAMa,GAAMA,EAAEC,QASjFP,OAAS,CAACQ,QAASC,oBACfC,kBAAoBD,WAAWE,qBAC9BH,QAAQR,QAAQY,MAASC,OAAOC,KAAKF,MAAMG,MAAMvB,KAClC,KAAdoB,KAAKpB,OAAeP,mBAAmB+B,SAASxB,MAG7CoB,KAAKpB,KAAKyB,WAAWN,cAAcK,SAASN,wBAYrDT,qBAAuB,CAACiB,qBAAsBC,cAAeV,oBACzDC,kBAAoBD,WAAWE,qBAC9BO,qBAAqB3B,KAAKqB,WACxB,MAAOpB,IAAK4B,SAAUP,OAAOQ,QAAQT,MAAO,iCACvCU,YAAcF,MAAMH,WAAWN,iBAChCW,YAAYN,SAASN,oBAI1BE,KAAKW,gDAAoBrC,iBAAiBsC,IAAIhC,4DAAQA,IACtDoB,KAAKa,cAAgBH,YAAYI,QAC7BhB,2DACkCD,uBAEtCG,KAAKe,KAAOR,cAAcP,KAAKgB,kBAG5BhB"}